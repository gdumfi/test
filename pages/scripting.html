<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bash & Python — DevOps Roadmap</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header class="header">
        <div class="container">
            <a href="../index.html" class="header-logo">&larr; DevOps Roadmap</a>
            <span class="header-title">Bash & Python</span>
            <span class="header-progress" id="headerProgress"></span>
        </div>
    </header>
    <main class="container">
        <div class="page-content">

            <!-- ===== HERO ===== -->
            <h1>Bash & Python</h1>
            <p class="subtitle">Автоматизация &mdash; суперсила DevOps-инженера. Два языка, которые закрывают 90% повседневных задач: от однострочников в терминале до сложных систем деплоя.</p>

            <!-- ===== 1. ВВЕДЕНИЕ ===== -->
            <h2>Введение</h2>
            <p>DevOps-инженер, не владеющий скриптингом, &mdash; всё равно что хирург без скальпеля. Ручное выполнение операций на серверах не масштабируется: один сервер можно настроить руками, десять &mdash; с трудом, сотню &mdash; невозможно. Скрипты превращают ручные действия в воспроизводимые, тестируемые, версионируемые артефакты.</p>
            <p><strong>Bash</strong> &mdash; язык командной оболочки Unix. Он идеально подходит для быстрых системных задач: проверить статус сервиса, ротировать логи, подготовить окружение перед запуском приложения. Bash доступен на любой Linux-машине из коробки &mdash; никаких зависимостей, никакой установки.</p>
            <p><strong>Python</strong> &mdash; универсальный язык программирования. Его выбирают для сложной логики: работа с API, парсинг структурированных данных (JSON, YAML), взаимодействие с облачными провайдерами, написание CLI-утилит. Богатая стандартная библиотека и тысячи пакетов в PyPI делают Python основным языком для инфраструктурного кода.</p>

            <div class="note">
                <strong>Когда что использовать?</strong> Практическое правило: если задачу можно решить в 10-20 строках с помощью стандартных Unix-утилит (grep, awk, sed, curl) &mdash; пишите на Bash. Если появляется сложная логика, обработка ошибок, работа с API или структурами данных &mdash; переходите на Python. Никогда не пишите на Bash то, что перерастёт в 200 строк &mdash; поддерживать такой скрипт будет крайне тяжело.
            </div>

            <!-- ===== 2. BASH — ОСНОВЫ ===== -->
            <h2>Bash &mdash; основы</h2>

            <h3>Shebang и запуск скриптов</h3>
            <p>Каждый Bash-скрипт начинается со строки <strong>shebang</strong> &mdash; она сообщает операционной системе, какой интерпретатор использовать для выполнения файла. Без shebang система попытается интерпретировать файл текущей оболочкой, что может привести к непредсказуемому поведению.</p>
            <div class="code-block">
                <div class="code-header">hello.sh</div>
<pre>
<span class="cm">#!/bin/bash</span>
<span class="cm"># Или более переносимый вариант:</span>
<span class="cm">#!/usr/bin/env bash</span>

<span class="fn">echo</span> <span class="st">"Hello, DevOps!"</span>
</pre>
            </div>
            <p>Чтобы сделать скрипт исполняемым и запустить:</p>
            <div class="code-block">
                <div class="code-header">terminal</div>
<pre>
<span class="fn">chmod</span> +x hello.sh      <span class="cm"># добавить права на выполнение</span>
./hello.sh              <span class="cm"># запустить скрипт</span>
<span class="fn">bash</span> hello.sh           <span class="cm"># альтернатива без chmod</span>
</pre>
            </div>

            <h3>Переменные и кавычки</h3>
            <p>В Bash переменные создаются без пробелов вокруг знака <code>=</code>. Это одна из самых частых ошибок у начинающих &mdash; пробел превращает присваивание в команду.</p>
            <div class="code-block">
                <div class="code-header">variables.sh</div>
<pre>
<span class="cm">#!/bin/bash</span>

<span class="cm"># Правильно:</span>
<span class="kw">NAME</span>=<span class="st">"production"</span>
<span class="kw">PORT</span>=<span class="fl">8080</span>

<span class="cm"># Неправильно (Bash воспримет NAME как команду):</span>
<span class="cm"># NAME = "production"</span>

<span class="cm"># Одинарные кавычки — буквальная строка, ничего не раскрывается:</span>
<span class="fn">echo</span> <span class="st">'Сервер: $NAME, порт: $PORT'</span>
<span class="cm"># Вывод: Сервер: $NAME, порт: $PORT</span>

<span class="cm"># Двойные кавычки — переменные и команды раскрываются:</span>
<span class="fn">echo</span> <span class="st">"Сервер: $NAME, порт: $PORT"</span>
<span class="cm"># Вывод: Сервер: production, порт: 8080</span>

<span class="cm"># Фигурные скобки для явного выделения имени переменной:</span>
<span class="fn">echo</span> <span class="st">"Лог: ${NAME}_app.log"</span>
<span class="cm"># Вывод: Лог: production_app.log</span>
</pre>
            </div>

            <h3>Подстановка команд</h3>
            <p>Конструкция <code>$(команда)</code> позволяет использовать вывод одной команды как значение переменной или аргумент другой команды. Устаревший синтаксис с обратными кавычками <code>`команда`</code> работает, но хуже читается и не поддерживает вложенность.</p>
            <div class="code-block">
                <div class="code-header">command_substitution.sh</div>
<pre>
<span class="cm">#!/bin/bash</span>

<span class="kw">CURRENT_DATE</span>=$(<span class="fn">date</span> +%Y-%m-%d)
<span class="kw">HOSTNAME</span>=$(<span class="fn">hostname</span>)
<span class="kw">DISK_USAGE</span>=$(<span class="fn">df</span> <span class="fl">-h</span> / | <span class="fn">awk</span> <span class="st">'NR==2{print $5}'</span>)

<span class="fn">echo</span> <span class="st">"Дата: $CURRENT_DATE"</span>
<span class="fn">echo</span> <span class="st">"Хост: $HOSTNAME"</span>
<span class="fn">echo</span> <span class="st">"Диск занят: $DISK_USAGE"</span>

<span class="cm"># Вложенная подстановка (невозможно с обратными кавычками):</span>
<span class="kw">CONFIG_DIR</span>=$(<span class="fn">dirname</span> $(<span class="fn">readlink</span> <span class="fl">-f</span> <span class="st">"$0"</span>))
</pre>
            </div>

            <h3>Коды выхода и set -euo pipefail</h3>
            <p>Каждая команда в Unix возвращает код выхода &mdash; число от 0 до 255. Код <code>0</code> означает успех, любое другое значение &mdash; ошибку. Код последней команды хранится в специальной переменной <code>$?</code>.</p>
            <div class="code-block">
                <div class="code-header">exit_codes.sh</div>
<pre>
<span class="cm">#!/bin/bash</span>

<span class="fn">grep</span> <span class="st">"root"</span> /etc/passwd
<span class="fn">echo</span> <span class="st">"Код выхода grep: $?"</span>   <span class="cm"># 0 — нашёл</span>

<span class="fn">grep</span> <span class="st">"несуществующий"</span> /etc/passwd
<span class="fn">echo</span> <span class="st">"Код выхода grep: $?"</span>   <span class="cm"># 1 — не нашёл</span>

<span class="fn">ls</span> /несуществующий/путь
<span class="fn">echo</span> <span class="st">"Код выхода ls: $?"</span>     <span class="cm"># 2 — ошибка</span>
</pre>
            </div>
            <p>Директива <code>set -euo pipefail</code> &mdash; обязательный заголовок продакшен-скриптов. Каждый флаг решает конкретную проблему:</p>
            <div class="code-block">
                <div class="code-header">strict_mode.sh</div>
<pre>
<span class="cm">#!/bin/bash</span>
<span class="kw">set</span> <span class="fl">-euo pipefail</span>

<span class="cm"># -e  — прервать скрипт при первой ошибке (ненулевой код выхода)</span>
<span class="cm"># -u  — ошибка при обращении к неопределённой переменной</span>
<span class="cm"># -o pipefail — код выхода пайплайна = код первой ошибки в цепочке</span>

<span class="cm"># Без pipefail ошибка curl замаскирована успехом wc:</span>
<span class="cm"># curl http://broken-url | wc -l  → код 0 (от wc)</span>

<span class="cm"># С pipefail:</span>
<span class="cm"># curl http://broken-url | wc -l  → код 6 (от curl)</span>
</pre>
            </div>
            <div class="note">
                <strong>Совет:</strong> Всегда начинайте Bash-скрипты строкой <code>set -euo pipefail</code>. Это превращает «тихие» ошибки в явные и предотвращает выполнение кода после сбоя. Без этих флагов скрипт продолжит работать после ошибки, что в продакшене может привести к потере данных.
            </div>

            <!-- ===== 3. BASH — УПРАВЛЯЮЩИЕ КОНСТРУКЦИИ ===== -->
            <h2>Bash &mdash; управляющие конструкции</h2>

            <h3>Условия: if / elif / else</h3>
            <p>Конструкция <code>if</code> в Bash проверяет код выхода команды. Если команда вернула <code>0</code> (успех), выполняется блок <code>then</code>. Команда <code>test</code> (она же <code>[ ]</code>) используется для сравнений. Более мощная конструкция <code>[[ ]]</code> &mdash; расширение Bash, поддерживающее регулярные выражения и логические операторы.</p>
            <div class="code-block">
                <div class="code-header">conditions.sh</div>
<pre>
<span class="cm">#!/bin/bash</span>
<span class="kw">set</span> <span class="fl">-euo pipefail</span>

<span class="kw">ENVIRONMENT</span>=<span class="st">"${1:-development}"</span>   <span class="cm"># аргумент или значение по умолчанию</span>

<span class="cm"># Базовое условие с [ ] (пробелы внутри скобок обязательны!):</span>
<span class="kw">if</span> [ <span class="st">"$ENVIRONMENT"</span> = <span class="st">"production"</span> ]; <span class="kw">then</span>
    <span class="fn">echo</span> <span class="st">"ВНИМАНИЕ: Деплой в production!"</span>
    <span class="kw">REPLICAS</span>=<span class="fl">3</span>
<span class="kw">elif</span> [ <span class="st">"$ENVIRONMENT"</span> = <span class="st">"staging"</span> ]; <span class="kw">then</span>
    <span class="fn">echo</span> <span class="st">"Деплой в staging"</span>
    <span class="kw">REPLICAS</span>=<span class="fl">2</span>
<span class="kw">else</span>
    <span class="fn">echo</span> <span class="st">"Деплой в development"</span>
    <span class="kw">REPLICAS</span>=<span class="fl">1</span>
<span class="kw">fi</span>

<span class="cm"># [[ ]] — поддерживает && и || напрямую:</span>
<span class="kw">if</span> [[ <span class="st">"$ENVIRONMENT"</span> == <span class="st">"production"</span> && <span class="st">"$REPLICAS"</span> <span class="fl">-lt</span> <span class="fl">2</span> ]]; <span class="kw">then</span>
    <span class="fn">echo</span> <span class="st">"Ошибка: production требует минимум 2 реплики"</span>
    <span class="kw">exit</span> <span class="fl">1</span>
<span class="kw">fi</span>

<span class="cm"># Проверка существования файлов и директорий:</span>
<span class="kw">if</span> [ <span class="fl">-f</span> <span class="st">"/etc/nginx/nginx.conf"</span> ]; <span class="kw">then</span>
    <span class="fn">echo</span> <span class="st">"Конфиг nginx найден"</span>
<span class="kw">fi</span>

<span class="kw">if</span> [ <span class="fl">-d</span> <span class="st">"/var/log/app"</span> ]; <span class="kw">then</span>
    <span class="fn">echo</span> <span class="st">"Директория логов существует"</span>
<span class="kw">fi</span>

<span class="kw">if</span> [ <span class="fl">-z</span> <span class="st">"$ENVIRONMENT"</span> ]; <span class="kw">then</span>
    <span class="fn">echo</span> <span class="st">"Переменная пуста"</span>
<span class="kw">fi</span>
</pre>
            </div>

            <h3>Циклы: for и while</h3>
            <div class="code-block">
                <div class="code-header">loops.sh</div>
<pre>
<span class="cm">#!/bin/bash</span>
<span class="kw">set</span> <span class="fl">-euo pipefail</span>

<span class="cm"># Итерация по списку:</span>
<span class="kw">for</span> server <span class="kw">in</span> web01 web02 web03 db01; <span class="kw">do</span>
    <span class="fn">echo</span> <span class="st">"Проверяю $server..."</span>
    <span class="fn">ssh</span> <span class="st">"$server"</span> <span class="st">"uptime"</span> || <span class="fn">echo</span> <span class="st">"$server недоступен"</span>
<span class="kw">done</span>

<span class="cm"># Итерация по файлам:</span>
<span class="kw">for</span> conf <span class="kw">in</span> /etc/nginx/sites-enabled/*.conf; <span class="kw">do</span>
    <span class="fn">echo</span> <span class="st">"Проверяю конфиг: $conf"</span>
    <span class="fn">nginx</span> <span class="fl">-t</span> <span class="fl">-c</span> <span class="st">"$conf"</span>
<span class="kw">done</span>

<span class="cm"># Числовой цикл (С-style):</span>
<span class="kw">for</span> ((i=1; i&lt;=5; i++)); <span class="kw">do</span>
    <span class="fn">echo</span> <span class="st">"Попытка $i из 5..."</span>
    <span class="kw">if</span> <span class="fn">curl</span> <span class="fl">-sf</span> http://localhost:8080/health; <span class="kw">then</span>
        <span class="fn">echo</span> <span class="st">"Сервис готов"</span>
        <span class="kw">break</span>
    <span class="kw">fi</span>
    <span class="fn">sleep</span> <span class="fl">5</span>
<span class="kw">done</span>

<span class="cm"># while — читаем вывод команды:</span>
<span class="fn">ps</span> aux | <span class="kw">while</span> <span class="fn">read</span> <span class="fl">-r</span> line; <span class="kw">do</span>
    <span class="kw">if</span> [[ <span class="st">"$line"</span> == *<span class="st">"zombie"</span>* ]]; <span class="kw">then</span>
        <span class="fn">echo</span> <span class="st">"ZOMBIE: $line"</span>
    <span class="kw">fi</span>
<span class="kw">done</span>
</pre>
            </div>

            <h3>case и функции</h3>
            <div class="code-block">
                <div class="code-header">case_and_functions.sh</div>
<pre>
<span class="cm">#!/bin/bash</span>
<span class="kw">set</span> <span class="fl">-euo pipefail</span>

<span class="cm"># case — аналог switch в других языках:</span>
<span class="kw">ACTION</span>=<span class="st">"${1:-help}"</span>

<span class="kw">case</span> <span class="st">"$ACTION"</span> <span class="kw">in</span>
    start)
        <span class="fn">echo</span> <span class="st">"Запуск сервиса..."</span>
        <span class="fn">systemctl</span> start myapp
        ;;
    stop)
        <span class="fn">echo</span> <span class="st">"Остановка сервиса..."</span>
        <span class="fn">systemctl</span> stop myapp
        ;;
    restart)
        <span class="fn">echo</span> <span class="st">"Перезапуск..."</span>
        <span class="fn">systemctl</span> restart myapp
        ;;
    status)
        <span class="fn">systemctl</span> status myapp
        ;;
    *)
        <span class="fn">echo</span> <span class="st">"Использование: $0 {start|stop|restart|status}"</span>
        <span class="kw">exit</span> <span class="fl">1</span>
        ;;
<span class="kw">esac</span>

<span class="cm"># Функции — переиспользуемые блоки кода:</span>
<span class="kw">log</span>() {
    <span class="kw">local</span> level=<span class="st">"$1"</span>
    <span class="kw">shift</span>
    <span class="fn">echo</span> <span class="st">"[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $*"</span>
}

<span class="kw">check_service</span>() {
    <span class="kw">local</span> service=<span class="st">"$1"</span>
    <span class="kw">if</span> <span class="fn">systemctl</span> is-active <span class="fl">--quiet</span> <span class="st">"$service"</span>; <span class="kw">then</span>
        <span class="fn">log</span> <span class="st">"INFO"</span> <span class="st">"$service работает"</span>
        <span class="kw">return</span> <span class="fl">0</span>
    <span class="kw">else</span>
        <span class="fn">log</span> <span class="st">"ERROR"</span> <span class="st">"$service не запущен!"</span>
        <span class="kw">return</span> <span class="fl">1</span>
    <span class="kw">fi</span>
}

<span class="cm"># Использование:</span>
<span class="fn">log</span> <span class="st">"INFO"</span> <span class="st">"Скрипт запущен"</span>
<span class="fn">check_service</span> <span class="st">"nginx"</span>
<span class="fn">check_service</span> <span class="st">"postgresql"</span>
</pre>
            </div>

            <!-- ===== 4. BASH — РАБОТА С ТЕКСТОМ ===== -->
            <h2>Bash &mdash; работа с текстом</h2>
            <p>Философия Unix: «каждая программа делает одну вещь хорошо». Маленькие утилиты соединяются в мощные конвейеры через пайпы (<code>|</code>). Это фундамент работы в командной строке.</p>

            <h3>Пайпы и перенаправление</h3>
            <div class="code-block">
                <div class="code-header">pipes_and_redirects.sh</div>
<pre>
<span class="cm"># Пайп (|) — передать stdout одной команды на stdin следующей:</span>
<span class="fn">cat</span> /var/log/syslog | <span class="fn">grep</span> <span class="st">"error"</span> | <span class="fn">wc</span> <span class="fl">-l</span>

<span class="cm"># Перенаправление вывода:</span>
<span class="fn">echo</span> <span class="st">"log entry"</span> &gt; file.log    <span class="cm"># перезаписать файл</span>
<span class="fn">echo</span> <span class="st">"log entry"</span> &gt;&gt; file.log   <span class="cm"># добавить в конец файла</span>

<span class="cm"># Перенаправление stderr:</span>
<span class="fn">command</span> 2&gt; errors.log            <span class="cm"># stderr в файл</span>
<span class="fn">command</span> &gt; output.log 2&gt;&amp;1        <span class="cm"># stdout и stderr в один файл</span>
<span class="fn">command</span> &amp;&gt; all.log               <span class="cm"># то же самое (синтаксис Bash)</span>

<span class="cm"># Подавление вывода:</span>
<span class="fn">command</span> &gt; /dev/null 2&gt;&amp;1         <span class="cm"># «чёрная дыра» — отбросить весь вывод</span>
</pre>
            </div>

            <h3>grep &mdash; поиск по тексту</h3>
            <div class="code-block">
                <div class="code-header">grep_examples.sh</div>
<pre>
<span class="cm"># Базовый поиск:</span>
<span class="fn">grep</span> <span class="st">"ERROR"</span> /var/log/app.log

<span class="cm"># -i  — без учёта регистра</span>
<span class="fn">grep</span> <span class="fl">-i</span> <span class="st">"error"</span> /var/log/app.log

<span class="cm"># -r  — рекурсивно по директории</span>
<span class="fn">grep</span> <span class="fl">-r</span> <span class="st">"TODO"</span> /home/user/project/

<span class="cm"># -n  — показать номера строк</span>
<span class="fn">grep</span> <span class="fl">-n</span> <span class="st">"connection refused"</span> /var/log/app.log

<span class="cm"># -c  — подсчитать совпадения</span>
<span class="fn">grep</span> <span class="fl">-c</span> <span class="st">"404"</span> /var/log/nginx/access.log

<span class="cm"># -v  — инвертировать (строки БЕЗ совпадения)</span>
<span class="fn">grep</span> <span class="fl">-v</span> <span class="st">"^#"</span> /etc/nginx/nginx.conf    <span class="cm"># убрать комментарии</span>

<span class="cm"># -E  — расширенные регулярные выражения (egrep)</span>
<span class="fn">grep</span> <span class="fl">-E</span> <span class="st">"(ERROR|CRITICAL|FATAL)"</span> /var/log/app.log

<span class="cm"># -A/-B/-C  — контекст (строки до/после/вокруг совпадения)</span>
<span class="fn">grep</span> <span class="fl">-A5</span> <span class="st">"Exception"</span> /var/log/app.log   <span class="cm"># 5 строк после совпадения</span>
</pre>
            </div>

            <h3>sed &mdash; потоковый редактор</h3>
            <div class="code-block">
                <div class="code-header">sed_examples.sh</div>
<pre>
<span class="cm"># Замена первого вхождения в каждой строке:</span>
<span class="fn">sed</span> <span class="st">'s/old/new/'</span> file.txt

<span class="cm"># Замена всех вхождений (флаг g):</span>
<span class="fn">sed</span> <span class="st">'s/old/new/g'</span> file.txt

<span class="cm"># Редактирование файла на месте (-i):</span>
<span class="fn">sed</span> <span class="fl">-i</span> <span class="st">'s/DEBUG/INFO/g'</span> config.yml

<span class="cm"># Удалить строки, содержащие паттерн:</span>
<span class="fn">sed</span> <span class="st">'/^#/d'</span> config.conf               <span class="cm"># удалить комментарии</span>
<span class="fn">sed</span> <span class="st">'/^$/d'</span> config.conf               <span class="cm"># удалить пустые строки</span>

<span class="cm"># Вставить строку перед/после совпадения:</span>
<span class="fn">sed</span> <span class="st">'/\[server\]/a\\    port = 8080'</span> config.ini

<span class="cm"># Извлечь строки по диапазону:</span>
<span class="fn">sed</span> <span class="fl">-n</span> <span class="st">'10,20p'</span> file.txt            <span class="cm"># строки с 10 по 20</span>
</pre>
            </div>

            <h3>awk &mdash; обработка колоночных данных</h3>
            <div class="code-block">
                <div class="code-header">awk_examples.sh</div>
<pre>
<span class="cm"># Вывести второе поле (разделитель — пробел по умолчанию):</span>
<span class="fn">awk</span> <span class="st">'{print $2}'</span> file.txt

<span class="cm"># Задать разделитель (: для /etc/passwd):</span>
<span class="fn">awk</span> <span class="fl">-F:</span> <span class="st">'{print $1, $7}'</span> /etc/passwd  <span class="cm"># пользователь и его shell</span>

<span class="cm"># Фильтрация строк по условию:</span>
<span class="fn">df</span> <span class="fl">-h</span> | <span class="fn">awk</span> <span class="st">'$5+0 > 80 {print "ALERT:", $6, "занят на", $5}'</span>

<span class="cm"># Суммирование столбца (например, размеры файлов):</span>
<span class="fn">ls</span> <span class="fl">-l</span> | <span class="fn">awk</span> <span class="st">'{sum += $5} END {print "Total:", sum/1024/1024, "MB"}'</span>

<span class="cm"># Подсчёт уникальных IP из access-лога:</span>
<span class="fn">awk</span> <span class="st">'{print $1}'</span> access.log | <span class="fn">sort</span> | <span class="fn">uniq</span> <span class="fl">-c</span> | <span class="fn">sort</span> <span class="fl">-rn</span> | <span class="fn">head</span> <span class="fl">-10</span>
</pre>
            </div>

            <h3>cut, sort, uniq, wc, xargs, tr</h3>
            <div class="code-block">
                <div class="code-header">text_tools.sh</div>
<pre>
<span class="cm"># cut — извлечь поля по разделителю:</span>
<span class="fn">cut</span> <span class="fl">-d:</span> <span class="fl">-f1</span> /etc/passwd            <span class="cm"># первое поле (имя пользователя)</span>
<span class="fn">cut</span> <span class="fl">-c1-10</span> file.txt                <span class="cm"># первые 10 символов каждой строки</span>

<span class="cm"># sort — сортировка:</span>
<span class="fn">sort</span> file.txt                        <span class="cm"># алфавитная</span>
<span class="fn">sort</span> <span class="fl">-n</span> file.txt                    <span class="cm"># числовая</span>
<span class="fn">sort</span> <span class="fl">-t, -k2 -n</span> data.csv           <span class="cm"># по второму полю CSV, числовая</span>
<span class="fn">sort</span> <span class="fl">-rn</span> file.txt                   <span class="cm"># обратная числовая</span>

<span class="cm"># uniq — убрать дубли (требует предварительной сортировки!):</span>
<span class="fn">sort</span> file.txt | <span class="fn">uniq</span>                <span class="cm"># уникальные строки</span>
<span class="fn">sort</span> file.txt | <span class="fn">uniq</span> <span class="fl">-c</span>             <span class="cm"># подсчёт повторов</span>
<span class="fn">sort</span> file.txt | <span class="fn">uniq</span> <span class="fl">-d</span>             <span class="cm"># только дубликаты</span>

<span class="cm"># wc — подсчёт строк, слов, символов:</span>
<span class="fn">wc</span> <span class="fl">-l</span> file.txt                      <span class="cm"># число строк</span>
<span class="fn">wc</span> <span class="fl">-w</span> file.txt                      <span class="cm"># число слов</span>
<span class="fn">find</span> . <span class="fl">-name</span> <span class="st">"*.py"</span> | <span class="fn">wc</span> <span class="fl">-l</span>        <span class="cm"># количество Python-файлов</span>

<span class="cm"># xargs — передать stdin как аргументы команде:</span>
<span class="fn">find</span> /tmp <span class="fl">-name</span> <span class="st">"*.log"</span> <span class="fl">-mtime</span> +30 | <span class="fn">xargs</span> <span class="fn">rm</span> <span class="fl">-f</span>
<span class="fn">cat</span> servers.txt | <span class="fn">xargs</span> <span class="fl">-I{}</span> <span class="fn">ssh</span> {} <span class="st">"uptime"</span>

<span class="cm"># tr — замена/удаление символов:</span>
<span class="fn">echo</span> <span class="st">"Hello World"</span> | <span class="fn">tr</span> <span class="st">'A-Z'</span> <span class="st">'a-z'</span>    <span class="cm"># в нижний регистр</span>
<span class="fn">echo</span> <span class="st">"a:b:c"</span> | <span class="fn">tr</span> <span class="st">':'</span> <span class="st">'\n'</span>              <span class="cm"># заменить : на перенос строки</span>
<span class="fn">cat</span> file.txt | <span class="fn">tr</span> <span class="fl">-d</span> <span class="st">'\r'</span>                <span class="cm"># удалить возврат каретки (Windows → Unix)</span>
</pre>
            </div>

            <!-- ===== 5. BASH — ПОЛЕЗНЫЕ ПАТТЕРНЫ ===== -->
            <h2>Bash &mdash; полезные паттерны</h2>

            <h3>Чтение файлов построчно</h3>
            <div class="code-block">
                <div class="code-header">read_file.sh</div>
<pre>
<span class="cm">#!/bin/bash</span>
<span class="kw">set</span> <span class="fl">-euo pipefail</span>

<span class="cm"># Чтение файла построчно (правильный способ):</span>
<span class="kw">while</span> <span class="fn">IFS</span>= <span class="fn">read</span> <span class="fl">-r</span> line; <span class="kw">do</span>
    <span class="fn">echo</span> <span class="st">"Обработка: $line"</span>
<span class="kw">done</span> &lt; /etc/hosts

<span class="cm"># Парсинг CSV:</span>
<span class="kw">while</span> <span class="fn">IFS</span>=<span class="st">','</span> <span class="fn">read</span> <span class="fl">-r</span> name ip role; <span class="kw">do</span>
    <span class="fn">echo</span> <span class="st">"Сервер: $name ($ip) — $role"</span>
<span class="kw">done</span> &lt; servers.csv

<span class="cm"># Парсинг лога — извлечь IP с ошибками 5xx:</span>
<span class="kw">while</span> <span class="fn">IFS</span>= <span class="fn">read</span> <span class="fl">-r</span> line; <span class="kw">do</span>
    <span class="kw">status</span>=$(<span class="fn">echo</span> <span class="st">"$line"</span> | <span class="fn">awk</span> <span class="st">'{print $9}'</span>)
    <span class="kw">if</span> [[ <span class="st">"$status"</span> =~ ^5 ]]; <span class="kw">then</span>
        <span class="fn">echo</span> <span class="st">"$line"</span> | <span class="fn">awk</span> <span class="st">'{print $1}'</span>
    <span class="kw">fi</span>
<span class="kw">done</span> &lt; /var/log/nginx/access.log
</pre>
            </div>

            <h3>trap &mdash; очистка при завершении</h3>
            <p>Команда <code>trap</code> позволяет перехватывать сигналы и выполнять код при завершении скрипта. Это необходимо для очистки временных файлов, снятия блокировок и корректного завершения.</p>
            <div class="code-block">
                <div class="code-header">trap_cleanup.sh</div>
<pre>
<span class="cm">#!/bin/bash</span>
<span class="kw">set</span> <span class="fl">-euo pipefail</span>

<span class="kw">TMPDIR</span>=$(<span class="fn">mktemp</span> <span class="fl">-d</span>)
<span class="kw">LOCKFILE</span>=<span class="st">"/var/run/deploy.lock"</span>

<span class="cm"># Функция очистки — выполнится при выходе, ошибке или Ctrl+C:</span>
<span class="kw">cleanup</span>() {
    <span class="fn">echo</span> <span class="st">"Очистка..."</span>
    <span class="fn">rm</span> <span class="fl">-rf</span> <span class="st">"$TMPDIR"</span>
    <span class="fn">rm</span> <span class="fl">-f</span> <span class="st">"$LOCKFILE"</span>
}

<span class="cm"># EXIT — при любом завершении, INT — Ctrl+C, TERM — kill:</span>
<span class="kw">trap</span> cleanup EXIT INT TERM

<span class="cm"># Создать lock-файл:</span>
<span class="fn">touch</span> <span class="st">"$LOCKFILE"</span>

<span class="cm"># Работаем во временной директории:</span>
<span class="fn">cd</span> <span class="st">"$TMPDIR"</span>
<span class="fn">echo</span> <span class="st">"Рабочая директория: $TMPDIR"</span>

<span class="cm"># ... основная логика скрипта ...</span>
<span class="cm"># Даже если здесь произойдёт ошибка, cleanup() отработает.</span>
</pre>
            </div>

            <h3>getopts &mdash; обработка аргументов</h3>
            <div class="code-block">
                <div class="code-header">getopts_example.sh</div>
<pre>
<span class="cm">#!/bin/bash</span>
<span class="kw">set</span> <span class="fl">-euo pipefail</span>

<span class="kw">ENVIRONMENT</span>=<span class="st">"development"</span>
<span class="kw">VERBOSE</span>=<span class="fl">0</span>
<span class="kw">TAG</span>=<span class="st">"latest"</span>

<span class="kw">usage</span>() {
    <span class="fn">echo</span> <span class="st">"Использование: $0 [-e environment] [-t tag] [-v] [-h]"</span>
    <span class="fn">echo</span> <span class="st">"  -e  Окружение (development|staging|production)"</span>
    <span class="fn">echo</span> <span class="st">"  -t  Тег Docker-образа"</span>
    <span class="fn">echo</span> <span class="st">"  -v  Подробный вывод"</span>
    <span class="fn">echo</span> <span class="st">"  -h  Показать справку"</span>
    <span class="kw">exit</span> <span class="fl">1</span>
}

<span class="kw">while</span> <span class="fn">getopts</span> <span class="st">"e:t:vh"</span> opt; <span class="kw">do</span>
    <span class="kw">case</span> <span class="st">"$opt"</span> <span class="kw">in</span>
        e) <span class="kw">ENVIRONMENT</span>=<span class="st">"$OPTARG"</span> ;;
        t) <span class="kw">TAG</span>=<span class="st">"$OPTARG"</span> ;;
        v) <span class="kw">VERBOSE</span>=<span class="fl">1</span> ;;
        h) <span class="fn">usage</span> ;;
        *) <span class="fn">usage</span> ;;
    <span class="kw">esac</span>
<span class="kw">done</span>

<span class="fn">echo</span> <span class="st">"Деплой: env=$ENVIRONMENT, tag=$TAG, verbose=$VERBOSE"</span>
</pre>
            </div>

            <h3>Here documents и подстановка процессов</h3>
            <div class="code-block">
                <div class="code-header">heredoc_and_process_sub.sh</div>
<pre>
<span class="cm">#!/bin/bash</span>
<span class="kw">set</span> <span class="fl">-euo pipefail</span>

<span class="cm"># Here document — многострочная строка:</span>
<span class="fn">cat</span> &lt;&lt;<span class="kw">EOF</span>
<span class="st">Отчёт о состоянии сервера
=========================
Дата: $(date)
Хост: $(hostname)
Uptime: $(uptime -p)
Диск: $(df -h / | awk 'NR==2{print $5}')</span>
<span class="kw">EOF</span>

<span class="cm"># Here document в файл:</span>
<span class="fn">cat</span> &lt;&lt;<span class="kw">EOF</span> &gt; /etc/nginx/conf.d/app.conf
<span class="st">server {
    listen 80;
    server_name example.com;
    location / {
        proxy_pass http://localhost:8080;
    }
}</span>
<span class="kw">EOF</span>

<span class="cm"># Подстановка процессов — сравнить вывод двух команд:</span>
<span class="fn">diff</span> &lt;(<span class="fn">ssh</span> web01 <span class="st">"cat /etc/hosts"</span>) &lt;(<span class="fn">ssh</span> web02 <span class="st">"cat /etc/hosts"</span>)

<span class="cm"># Подсчитать количество запущенных контейнеров по образу:</span>
<span class="kw">while</span> <span class="fn">read</span> <span class="fl">-r</span> count image; <span class="kw">do</span>
    <span class="fn">echo</span> <span class="st">"$image: $count контейнер(ов)"</span>
<span class="kw">done</span> &lt; &lt;(<span class="fn">docker</span> ps --format <span class="st">"{{.Image}}"</span> | <span class="fn">sort</span> | <span class="fn">uniq</span> <span class="fl">-c</span>)
</pre>
            </div>

            <!-- ===== 6. PYTHON — ОСНОВЫ ДЛЯ DEVOPS ===== -->
            <h2>Python &mdash; основы для DevOps</h2>
            <p>Python &mdash; второй обязательный инструмент в арсенале DevOps-инженера. Его сильные стороны: читаемый синтаксис, мощная стандартная библиотека, огромная экосистема пакетов для работы с облаками, API, конфигурациями.</p>

            <h3>Переменные и типы данных</h3>
            <div class="code-block">
                <div class="code-header">basics.py</div>
<pre>
<span class="cm"># Переменные — типизация динамическая, объявление не нужно:</span>
<span class="kw">hostname</span> = <span class="st">"web-prod-01"</span>
<span class="kw">port</span> = <span class="fl">8080</span>
<span class="kw">is_healthy</span> = <span class="fl">True</span>
<span class="kw">cpu_load</span> = <span class="fl">73.5</span>

<span class="cm"># f-строки (Python 3.6+) — лучший способ форматирования:</span>
<span class="fn">print</span>(<span class="st">f"Сервер </span><span class="kw">{hostname}</span><span class="st"> на порту </span><span class="kw">{port}</span><span class="st">, CPU: </span><span class="kw">{cpu_load}</span><span class="st">%"</span>)

<span class="cm"># Списки (list) — упорядоченная коллекция:</span>
<span class="kw">servers</span> = [<span class="st">"web01"</span>, <span class="st">"web02"</span>, <span class="st">"web03"</span>, <span class="st">"db01"</span>]
<span class="kw">servers</span>.<span class="fn">append</span>(<span class="st">"cache01"</span>)
<span class="kw">web_servers</span> = [s <span class="kw">for</span> s <span class="kw">in</span> servers <span class="kw">if</span> s.<span class="fn">startswith</span>(<span class="st">"web"</span>)]

<span class="cm"># Словари (dict) — пары ключ-значение:</span>
<span class="kw">service</span> = {
    <span class="st">"name"</span>: <span class="st">"api-gateway"</span>,
    <span class="st">"port"</span>: <span class="fl">443</span>,
    <span class="st">"replicas"</span>: <span class="fl">3</span>,
    <span class="st">"healthy"</span>: <span class="fl">True</span>,
    <span class="st">"tags"</span>: [<span class="st">"production"</span>, <span class="st">"critical"</span>]
}

<span class="fn">print</span>(<span class="st">f"Сервис: </span><span class="kw">{service[<span class="st">'name'</span>]}</span><span class="st">, реплик: </span><span class="kw">{service[<span class="st">'replicas'</span>]}</span><span class="st">"</span>)

<span class="cm"># Comprehensions — компактные конструкции:</span>
<span class="kw">ports</span> = [<span class="fl">8080</span>, <span class="fl">8081</span>, <span class="fl">8082</span>, <span class="fl">443</span>, <span class="fl">80</span>]
<span class="kw">high_ports</span> = [p <span class="kw">for</span> p <span class="kw">in</span> ports <span class="kw">if</span> p &gt; <span class="fl">1024</span>]

<span class="cm"># Dict comprehension:</span>
<span class="kw">server_status</span> = {s: <span class="st">"healthy"</span> <span class="kw">for</span> s <span class="kw">in</span> servers}
</pre>
            </div>

            <h3>Функции и обработка ошибок</h3>
            <div class="code-block">
                <div class="code-header">functions.py</div>
<pre>
<span class="kw">import</span> sys

<span class="kw">def</span> <span class="fn">check_disk_space</span>(path: str, threshold: int = <span class="fl">80</span>) -&gt; dict:
    <span class="st">"""Проверить использование диска. Возвращает словарь с результатом."""</span>
    <span class="kw">import</span> shutil
    usage = shutil.<span class="fn">disk_usage</span>(path)
    percent = (usage.used / usage.total) * <span class="fl">100</span>
    <span class="kw">return</span> {
        <span class="st">"path"</span>: path,
        <span class="st">"percent"</span>: <span class="fn">round</span>(percent, <span class="fl">1</span>),
        <span class="st">"alert"</span>: percent &gt; threshold,
        <span class="st">"free_gb"</span>: <span class="fn">round</span>(usage.free / (<span class="fl">1024</span>**<span class="fl">3</span>), <span class="fl">2</span>)
    }

<span class="cm"># Обработка ошибок — try/except:</span>
<span class="kw">def</span> <span class="fn">safe_read_config</span>(filepath: str) -&gt; str:
    <span class="kw">try</span>:
        <span class="kw">with</span> <span class="fn">open</span>(filepath, <span class="st">"r"</span>) <span class="kw">as</span> f:
            <span class="kw">return</span> f.<span class="fn">read</span>()
    <span class="kw">except</span> FileNotFoundError:
        <span class="fn">print</span>(<span class="st">f"Файл не найден: </span><span class="kw">{filepath}</span><span class="st">"</span>, file=sys.stderr)
        sys.<span class="fn">exit</span>(<span class="fl">1</span>)
    <span class="kw">except</span> PermissionError:
        <span class="fn">print</span>(<span class="st">f"Нет доступа к файлу: </span><span class="kw">{filepath}</span><span class="st">"</span>, file=sys.stderr)
        sys.<span class="fn">exit</span>(<span class="fl">1</span>)

<span class="cm"># Использование:</span>
result = <span class="fn">check_disk_space</span>(<span class="st">"/"</span>)
<span class="kw">if</span> result[<span class="st">"alert"</span>]:
    <span class="fn">print</span>(<span class="st">f"ALERT: Диск {result[<span class="st">'path'</span>]} заполнен на {result[<span class="st">'percent'</span>]}%"</span>)
</pre>
            </div>

            <!-- ===== 7. PYTHON — ФАЙЛЫ И ДАННЫЕ ===== -->
            <h2>Python &mdash; работа с файлами и данными</h2>

            <h3>Работа с файлами через pathlib и open()</h3>
            <div class="code-block">
                <div class="code-header">files.py</div>
<pre>
<span class="kw">from</span> pathlib <span class="kw">import</span> Path

<span class="cm"># pathlib — современный способ работы с путями:</span>
config_dir = Path(<span class="st">"/etc/myapp"</span>)
config_file = config_dir / <span class="st">"config.yml"</span>   <span class="cm"># /etc/myapp/config.yml</span>

<span class="cm"># Проверки:</span>
<span class="kw">if</span> <span class="kw">not</span> config_file.<span class="fn">exists</span>():
    <span class="fn">print</span>(<span class="st">"Конфиг не найден!"</span>)

<span class="cm"># Создать директорию (включая родительские):</span>
Path(<span class="st">"/var/log/myapp"</span>).<span class="fn">mkdir</span>(parents=<span class="fl">True</span>, exist_ok=<span class="fl">True</span>)

<span class="cm"># Чтение и запись файлов:</span>
content = config_file.<span class="fn">read_text</span>(encoding=<span class="st">"utf-8"</span>)
Path(<span class="st">"/tmp/output.txt"</span>).<span class="fn">write_text</span>(<span class="st">"Hello"</span>, encoding=<span class="st">"utf-8"</span>)

<span class="cm"># Найти все YAML-файлы рекурсивно:</span>
<span class="kw">for</span> yml <span class="kw">in</span> Path(<span class="st">"/etc"</span>).<span class="fn">rglob</span>(<span class="st">"*.yml"</span>):
    <span class="fn">print</span>(yml)

<span class="cm"># Контекстный менеджер для работы с файлом:</span>
<span class="kw">with</span> <span class="fn">open</span>(<span class="st">"/var/log/app.log"</span>, <span class="st">"r"</span>) <span class="kw">as</span> f:
    <span class="kw">for</span> line <span class="kw">in</span> f:
        <span class="kw">if</span> <span class="st">"ERROR"</span> <span class="kw">in</span> line:
            <span class="fn">print</span>(line.strip())
</pre>
            </div>

            <h3>Работа с JSON</h3>
            <div class="code-block">
                <div class="code-header">json_example.py</div>
<pre>
<span class="kw">import</span> json
<span class="kw">from</span> pathlib <span class="kw">import</span> Path

<span class="cm"># Чтение JSON-файла:</span>
data = json.<span class="fn">loads</span>(Path(<span class="st">"config.json"</span>).<span class="fn">read_text</span>())

<span class="cm"># Или через open():</span>
<span class="kw">with</span> <span class="fn">open</span>(<span class="st">"config.json"</span>) <span class="kw">as</span> f:
    data = json.<span class="fn">load</span>(f)

<span class="cm"># Работа с данными:</span>
<span class="fn">print</span>(<span class="st">f"Сервис: {data[<span class="st">'service'</span>][<span class="st">'name'</span>]}"</span>)
<span class="fn">print</span>(<span class="st">f"Порт: {data[<span class="st">'service'</span>][<span class="st">'port'</span>]}"</span>)

<span class="cm"># Безопасный доступ (без KeyError):</span>
replicas = data.<span class="fn">get</span>(<span class="st">"replicas"</span>, <span class="fl">1</span>)

<span class="cm"># Запись JSON с форматированием:</span>
output = {
    <span class="st">"timestamp"</span>: <span class="st">"2025-01-15T10:30:00Z"</span>,
    <span class="st">"status"</span>: <span class="st">"healthy"</span>,
    <span class="st">"checks"</span>: [
        {<span class="st">"name"</span>: <span class="st">"disk"</span>, <span class="st">"passed"</span>: <span class="fl">True</span>},
        {<span class="st">"name"</span>: <span class="st">"memory"</span>, <span class="st">"passed"</span>: <span class="fl">True</span>}
    ]
}

Path(<span class="st">"report.json"</span>).<span class="fn">write_text</span>(
    json.<span class="fn">dumps</span>(output, indent=<span class="fl">2</span>, ensure_ascii=<span class="fl">False</span>)
)
</pre>
            </div>

            <h3>Работа с YAML и CSV</h3>
            <div class="code-block">
                <div class="code-header">yaml_csv.py</div>
<pre>
<span class="cm"># YAML — основной формат конфигураций в DevOps (Ansible, K8s, Docker Compose):</span>
<span class="kw">import</span> yaml   <span class="cm"># pip install pyyaml</span>

<span class="kw">with</span> <span class="fn">open</span>(<span class="st">"docker-compose.yml"</span>) <span class="kw">as</span> f:
    compose = yaml.<span class="fn">safe_load</span>(f)

<span class="cm"># Перебрать все сервисы в docker-compose:</span>
<span class="kw">for</span> name, config <span class="kw">in</span> compose[<span class="st">"services"</span>].<span class="fn">items</span>():
    image = config.<span class="fn">get</span>(<span class="st">"image"</span>, <span class="st">"build-контекст"</span>)
    ports = config.<span class="fn">get</span>(<span class="st">"ports"</span>, [])
    <span class="fn">print</span>(<span class="st">f"{name}: {image}, порты: {ports}"</span>)

<span class="cm"># Генерация YAML:</span>
config = {
    <span class="st">"apiVersion"</span>: <span class="st">"apps/v1"</span>,
    <span class="st">"kind"</span>: <span class="st">"Deployment"</span>,
    <span class="st">"metadata"</span>: {<span class="st">"name"</span>: <span class="st">"web"</span>, <span class="st">"namespace"</span>: <span class="st">"production"</span>}
}

<span class="kw">with</span> <span class="fn">open</span>(<span class="st">"deployment.yml"</span>, <span class="st">"w"</span>) <span class="kw">as</span> f:
    yaml.<span class="fn">dump</span>(config, f, default_flow_style=<span class="fl">False</span>, allow_unicode=<span class="fl">True</span>)

<span class="cm"># CSV — табличные данные:</span>
<span class="kw">import</span> csv

<span class="kw">with</span> <span class="fn">open</span>(<span class="st">"inventory.csv"</span>) <span class="kw">as</span> f:
    reader = csv.<span class="fn">DictReader</span>(f)
    <span class="kw">for</span> row <span class="kw">in</span> reader:
        <span class="fn">print</span>(<span class="st">f"Хост: {row[<span class="st">'hostname'</span>]}, IP: {row[<span class="st">'ip'</span>]}, Роль: {row[<span class="st">'role'</span>]}"</span>)
</pre>
            </div>

            <!-- ===== 8. PYTHON — АВТОМАТИЗАЦИЯ ===== -->
            <h2>Python &mdash; автоматизация</h2>

            <h3>Запуск системных команд (subprocess)</h3>
            <p>Модуль <code>subprocess</code> &mdash; правильный способ запуска внешних команд из Python. Забудьте про <code>os.system()</code> &mdash; он небезопасен и не даёт контроля над stdout/stderr.</p>
            <div class="code-block">
                <div class="code-header">subprocess_example.py</div>
<pre>
<span class="kw">import</span> subprocess
<span class="kw">import</span> sys

<span class="cm"># Простой запуск с проверкой результата:</span>
result = subprocess.<span class="fn">run</span>(
    [<span class="st">"docker"</span>, <span class="st">"ps"</span>, <span class="st">"--format"</span>, <span class="st">"{{.Names}}"</span>],
    capture_output=<span class="fl">True</span>,
    text=<span class="fl">True</span>,
    check=<span class="fl">True</span>   <span class="cm"># выбросит CalledProcessError при ошибке</span>
)

containers = result.stdout.strip().<span class="fn">split</span>(<span class="st">"\n"</span>)
<span class="fn">print</span>(<span class="st">f"Запущено контейнеров: {<span class="fn">len</span>(containers)}"</span>)

<span class="cm"># Обработка ошибок:</span>
<span class="kw">try</span>:
    subprocess.<span class="fn">run</span>(
        [<span class="st">"systemctl"</span>, <span class="st">"restart"</span>, <span class="st">"nginx"</span>],
        check=<span class="fl">True</span>,
        capture_output=<span class="fl">True</span>,
        text=<span class="fl">True</span>
    )
    <span class="fn">print</span>(<span class="st">"Nginx перезапущен"</span>)
<span class="kw">except</span> subprocess.CalledProcessError <span class="kw">as</span> e:
    <span class="fn">print</span>(<span class="st">f"Ошибка: {e.stderr}"</span>, file=sys.stderr)
    sys.<span class="fn">exit</span>(<span class="fl">1</span>)

<span class="cm"># Пайплайн команд:</span>
ps = subprocess.<span class="fn">Popen</span>(
    [<span class="st">"ps"</span>, <span class="st">"aux"</span>],
    stdout=subprocess.PIPE
)
grep = subprocess.<span class="fn">Popen</span>(
    [<span class="st">"grep"</span>, <span class="st">"python"</span>],
    stdin=ps.stdout,
    stdout=subprocess.PIPE,
    text=<span class="fl">True</span>
)
ps.stdout.<span class="fn">close</span>()
output = grep.<span class="fn">communicate</span>()[<span class="fl">0</span>]
<span class="fn">print</span>(output)
</pre>
            </div>

            <h3>HTTP-запросы (requests)</h3>
            <div class="code-block">
                <div class="code-header">http_api.py</div>
<pre>
<span class="kw">import</span> requests   <span class="cm"># pip install requests</span>

<span class="cm"># GET-запрос к API:</span>
response = requests.<span class="fn">get</span>(
    <span class="st">"https://api.github.com/repos/torvalds/linux"</span>,
    headers={<span class="st">"Accept"</span>: <span class="st">"application/json"</span>},
    timeout=<span class="fl">10</span>
)
response.<span class="fn">raise_for_status</span>()   <span class="cm"># HTTPError если 4xx/5xx</span>

repo = response.<span class="fn">json</span>()
<span class="fn">print</span>(<span class="st">f"Stars: {repo[<span class="st">'stargazers_count'</span>]}"</span>)

<span class="cm"># POST-запрос (webhook / notification):</span>
payload = {
    <span class="st">"text"</span>: <span class="st">"Деплой v2.1.0 завершён успешно"</span>,
    <span class="st">"channel"</span>: <span class="st">"#deployments"</span>
}
response = requests.<span class="fn">post</span>(
    <span class="st">"https://hooks.slack.com/services/XXX/YYY/ZZZ"</span>,
    json=payload,
    timeout=<span class="fl">10</span>
)

<span class="cm"># Работа с сессиями (переиспользование соединений):</span>
session = requests.<span class="fn">Session</span>()
session.headers.<span class="fn">update</span>({
    <span class="st">"Authorization"</span>: <span class="st">"Bearer TOKEN"</span>,
    <span class="st">"Content-Type"</span>: <span class="st">"application/json"</span>
})

<span class="cm"># Теперь все запросы через session используют эти заголовки:</span>
r1 = session.<span class="fn">get</span>(<span class="st">"https://api.example.com/health"</span>)
r2 = session.<span class="fn">get</span>(<span class="st">"https://api.example.com/metrics"</span>)
</pre>
            </div>

            <h3>SSH (paramiko) и работа с файловой системой</h3>
            <div class="code-block">
                <div class="code-header">ssh_and_files.py</div>
<pre>
<span class="kw">import</span> paramiko   <span class="cm"># pip install paramiko</span>
<span class="kw">import</span> shutil
<span class="kw">import</span> os

<span class="cm"># SSH-подключение и выполнение команд:</span>
client = paramiko.<span class="fn">SSHClient</span>()
client.<span class="fn">set_missing_host_key_policy</span>(paramiko.AutoAddPolicy())
client.<span class="fn">connect</span>(
    hostname=<span class="st">"192.168.1.10"</span>,
    username=<span class="st">"deploy"</span>,
    key_filename=<span class="st">"/home/deploy/.ssh/id_rsa"</span>
)

stdin, stdout, stderr = client.<span class="fn">exec_command</span>(<span class="st">"df -h / | awk 'NR==2{print $5}'"</span>)
disk_usage = stdout.<span class="fn">read</span>().<span class="fn">decode</span>().strip()
<span class="fn">print</span>(<span class="st">f"Использование диска: {disk_usage}"</span>)

client.<span class="fn">close</span>()

<span class="cm"># Работа с файловой системой (shutil, os):</span>
shutil.<span class="fn">copy2</span>(<span class="st">"config.yml"</span>, <span class="st">"config.yml.bak"</span>)       <span class="cm"># копия с метаданными</span>
shutil.<span class="fn">copytree</span>(<span class="st">"src/"</span>, <span class="st">"backup/src/"</span>)              <span class="cm"># рекурсивное копирование</span>
shutil.<span class="fn">rmtree</span>(<span class="st">"/tmp/old-build"</span>)                    <span class="cm"># удалить директорию</span>
shutil.<span class="fn">disk_usage</span>(<span class="st">"/"</span>)                              <span class="cm"># информация о диске</span>

<span class="cm"># Переменные окружения:</span>
db_host = os.environ.<span class="fn">get</span>(<span class="st">"DB_HOST"</span>, <span class="st">"localhost"</span>)
api_key = os.environ[<span class="st">"API_KEY"</span>]   <span class="cm"># KeyError если не задана</span>
</pre>
            </div>

            <h3>AWS (boto3) и виртуальные окружения</h3>
            <div class="code-block">
                <div class="code-header">aws_and_venv.py</div>
<pre>
<span class="cm"># boto3 — официальный SDK для AWS:</span>
<span class="kw">import</span> boto3   <span class="cm"># pip install boto3</span>

<span class="cm"># Получить список EC2-инстансов:</span>
ec2 = boto3.<span class="fn">client</span>(<span class="st">"ec2"</span>, region_name=<span class="st">"eu-west-1"</span>)
response = ec2.<span class="fn">describe_instances</span>(
    Filters=[{<span class="st">"Name"</span>: <span class="st">"tag:Environment"</span>, <span class="st">"Values"</span>: [<span class="st">"production"</span>]}]
)

<span class="kw">for</span> reservation <span class="kw">in</span> response[<span class="st">"Reservations"</span>]:
    <span class="kw">for</span> instance <span class="kw">in</span> reservation[<span class="st">"Instances"</span>]:
        <span class="fn">print</span>(<span class="st">f"{instance[<span class="st">'InstanceId'</span>]}: {instance[<span class="st">'State'</span>][<span class="st">'Name'</span>]}"</span>)

<span class="cm"># Загрузить файл в S3:</span>
s3 = boto3.<span class="fn">client</span>(<span class="st">"s3"</span>)
s3.<span class="fn">upload_file</span>(<span class="st">"backup.tar.gz"</span>, <span class="st">"my-bucket"</span>, <span class="st">"backups/2025-01-15.tar.gz"</span>)
</pre>
            </div>
            <div class="code-block">
                <div class="code-header">terminal — виртуальные окружения</div>
<pre>
<span class="cm"># Создание виртуального окружения:</span>
<span class="fn">python3</span> <span class="fl">-m</span> venv .venv

<span class="cm"># Активация:</span>
<span class="fn">source</span> .venv/bin/activate     <span class="cm"># Linux/macOS</span>
<span class="cm"># .venv\Scripts\activate     # Windows</span>

<span class="cm"># Установка пакетов:</span>
<span class="fn">pip</span> install requests pyyaml paramiko boto3

<span class="cm"># Сохранить зависимости:</span>
<span class="fn">pip</span> freeze &gt; requirements.txt

<span class="cm"># Установить из файла (на другой машине):</span>
<span class="fn">pip</span> install <span class="fl">-r</span> requirements.txt

<span class="cm"># Деактивация:</span>
<span class="fn">deactivate</span>
</pre>
            </div>
            <div class="note">
                <strong>Всегда используйте виртуальные окружения!</strong> Установка пакетов глобально (<code>pip install</code> без venv) загрязняет системный Python и приводит к конфликтам версий. Каждый проект должен иметь свой <code>venv</code> и <code>requirements.txt</code> с зафиксированными версиями пакетов.
            </div>

            <!-- ===== 9. CRON И АВТОМАТИЗАЦИЯ ===== -->
            <h2>Cron и автоматизация по расписанию</h2>
            <p>Cron &mdash; планировщик задач в Unix/Linux, который выполняет команды по расписанию. Это один из самых старых и надёжных компонентов системы, но у него есть свои подводные камни.</p>

            <h3>Синтаксис crontab</h3>
            <div class="code-block">
                <div class="code-header">crontab -e</div>
<pre>
<span class="cm"># Формат: минута час день_месяца месяц день_недели команда</span>
<span class="cm">#         (0-59) (0-23) (1-31)     (1-12) (0-7, 0=вс)</span>

<span class="cm"># Каждый день в 3:00 ночи — ротация логов:</span>
<span class="fl">0</span> <span class="fl">3</span> * * *    /usr/local/bin/rotate-logs.sh

<span class="cm"># Каждые 5 минут — проверка здоровья:</span>
*/5 * * * *  /usr/local/bin/healthcheck.sh

<span class="cm"># Каждый понедельник в 9:00 — отчёт:</span>
<span class="fl">0</span> <span class="fl">9</span> * * <span class="fl">1</span>   /usr/local/bin/weekly-report.py

<span class="cm"># Первый день каждого месяца в 0:00 — бэкап:</span>
<span class="fl">0</span> <span class="fl">0</span> <span class="fl">1</span> * *   /usr/local/bin/monthly-backup.sh

<span class="cm"># Каждый рабочий день (пн-пт) в 8:00 и 18:00:</span>
<span class="fl">0</span> <span class="fl">8,18</span> * * <span class="fl">1-5</span>  /usr/local/bin/deploy-check.sh

<span class="cm"># Каждые 30 минут с 9 до 18:</span>
*/30 <span class="fl">9-18</span> * * *  /usr/local/bin/monitor.sh
</pre>
            </div>

            <h3>Подводные камни cron</h3>
            <div class="note">
                <strong>PATH в cron:</strong> Среда cron минимальна &mdash; переменная <code>PATH</code> обычно содержит только <code>/usr/bin:/bin</code>. Это означает, что команды вроде <code>docker</code>, <code>python3</code>, <code>aws</code> не будут найдены. Всегда используйте полные пути к командам или задайте PATH в начале crontab.
            </div>
            <div class="code-block">
                <div class="code-header">crontab — правильная настройка</div>
<pre>
<span class="cm"># Задать PATH и переменные в начале crontab:</span>
<span class="kw">PATH</span>=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
<span class="kw">SHELL</span>=/bin/bash
<span class="kw">MAILTO</span>=admin@example.com

<span class="cm"># Логировать вывод задач:</span>
<span class="fl">0</span> <span class="fl">3</span> * * *  /usr/local/bin/backup.sh &gt;&gt; /var/log/cron-backup.log 2&gt;&amp;1

<span class="cm"># Предотвратить параллельный запуск (flock):</span>
*/5 * * * *  <span class="fn">flock</span> <span class="fl">-n</span> /var/lock/healthcheck.lock /usr/local/bin/healthcheck.sh
</pre>
            </div>

            <h3>systemd timers как альтернатива</h3>
            <p>Современная альтернатива cron &mdash; systemd timers. Они поддерживают логирование через journald, зависимости от других сервисов, и более гибкое расписание.</p>
            <div class="code-block">
                <div class="code-header">/etc/systemd/system/backup.service</div>
<pre>
<span class="kw">[Unit]</span>
<span class="fn">Description</span>=<span class="st">Daily backup script</span>

<span class="kw">[Service]</span>
<span class="fn">Type</span>=<span class="st">oneshot</span>
<span class="fn">ExecStart</span>=<span class="st">/usr/local/bin/backup.sh</span>
<span class="fn">User</span>=<span class="st">backup</span>
<span class="fn">StandardOutput</span>=<span class="st">journal</span>
<span class="fn">StandardError</span>=<span class="st">journal</span>
</pre>
            </div>
            <div class="code-block">
                <div class="code-header">/etc/systemd/system/backup.timer</div>
<pre>
<span class="kw">[Unit]</span>
<span class="fn">Description</span>=<span class="st">Run backup daily at 3am</span>

<span class="kw">[Timer]</span>
<span class="fn">OnCalendar</span>=<span class="st">*-*-* 03:00:00</span>
<span class="fn">Persistent</span>=<span class="st">true</span>    <span class="cm"># запустить, если пропущено (машина была выключена)</span>

<span class="kw">[Install]</span>
<span class="fn">WantedBy</span>=<span class="st">timers.target</span>
</pre>
            </div>
            <div class="code-block">
                <div class="code-header">terminal — управление таймером</div>
<pre>
<span class="fn">sudo</span> systemctl daemon-reload
<span class="fn">sudo</span> systemctl enable backup.timer
<span class="fn">sudo</span> systemctl start backup.timer

<span class="cm"># Проверить статус всех таймеров:</span>
<span class="fn">systemctl</span> list-timers <span class="fl">--all</span>

<span class="cm"># Посмотреть логи:</span>
<span class="fn">journalctl</span> <span class="fl">-u</span> backup.service <span class="fl">-f</span>
</pre>
            </div>

            <!-- ===== 10. ПОШАГОВЫЙ ТУТОРИАЛ ===== -->
            <h2>Пошаговый туториал</h2>
            <p>Создадим реальную систему мониторинга и оповещений. Bash-скрипт проверяет состояние диска и ротирует логи, Python-модуль отправляет уведомления в Telegram.</p>

            <div class="step">
                <div class="step-num">Шаг 1 — Проверка дискового пространства (Bash)</div>
                <p>Начнём с функции, которая проверяет использование диска на каждом смонтированном разделе и возвращает список проблемных.</p>
                <div class="code-block">
                    <div class="code-header">monitor.sh — часть 1</div>
<pre>
<span class="cm">#!/bin/bash</span>
<span class="kw">set</span> <span class="fl">-euo pipefail</span>

<span class="cm"># Конфигурация:</span>
<span class="kw">DISK_THRESHOLD</span>=<span class="fl">80</span>         <span class="cm"># процент заполненности диска</span>
<span class="kw">LOG_DIR</span>=<span class="st">"/var/log/myapp"</span>
<span class="kw">LOG_MAX_AGE</span>=<span class="fl">30</span>            <span class="cm"># удалять логи старше 30 дней</span>
<span class="kw">ALERT_SCRIPT</span>=<span class="st">"$(dirname "$0")/alert.py"</span>

<span class="cm"># Функция логирования:</span>
<span class="kw">log</span>() {
    <span class="fn">echo</span> <span class="st">"[$(date '+%Y-%m-%d %H:%M:%S')] $*"</span>
}

<span class="cm"># Проверка дискового пространства:</span>
<span class="kw">check_disk</span>() {
    log <span class="st">"Проверка дискового пространства..."</span>
    <span class="kw">local</span> alerts=<span class="st">""</span>

    <span class="kw">while</span> <span class="fn">read</span> <span class="fl">-r</span> filesystem size used avail percent mount; <span class="kw">do</span>
        <span class="cm"># Убрать % из числа:</span>
        <span class="kw">pct</span>=<span class="st">"${percent%\%}"</span>

        <span class="kw">if</span> [ <span class="st">"$pct"</span> <span class="fl">-gt</span> <span class="st">"$DISK_THRESHOLD"</span> ]; <span class="kw">then</span>
            log <span class="st">"ALERT: $mount заполнен на ${pct}% (порог: ${DISK_THRESHOLD}%)"</span>
            <span class="kw">alerts</span>+=<span class="st">"Раздел $mount: ${pct}% (свободно: $avail)\n"</span>
        <span class="kw">else</span>
            log <span class="st">"OK: $mount — ${pct}%"</span>
        <span class="kw">fi</span>
    <span class="kw">done</span> &lt; &lt;(<span class="fn">df</span> <span class="fl">-h</span> <span class="fl">--output=source,size,used,avail,pcent,target</span> <span class="fl">-x tmpfs</span> <span class="fl">-x devtmpfs</span> | <span class="fn">tail</span> <span class="fl">-n+2</span>)

    <span class="fn">echo</span> <span class="st">"$alerts"</span>
}
</pre>
                </div>
            </div>

            <div class="step">
                <div class="step-num">Шаг 2 — Ротация логов (Bash)</div>
                <p>Добавляем функцию, которая удаляет старые лог-файлы и сжимает свежие.</p>
                <div class="code-block">
                    <div class="code-header">monitor.sh — часть 2</div>
<pre>
<span class="cm"># Ротация логов:</span>
<span class="kw">rotate_logs</span>() {
    log <span class="st">"Ротация логов в $LOG_DIR..."</span>

    <span class="kw">if</span> [ ! <span class="fl">-d</span> <span class="st">"$LOG_DIR"</span> ]; <span class="kw">then</span>
        log <span class="st">"Директория $LOG_DIR не существует, пропускаю"</span>
        <span class="kw">return</span> <span class="fl">0</span>
    <span class="kw">fi</span>

    <span class="cm"># Удалить логи старше LOG_MAX_AGE дней:</span>
    <span class="kw">local</span> deleted
    deleted=$(<span class="fn">find</span> <span class="st">"$LOG_DIR"</span> <span class="fl">-name</span> <span class="st">"*.log"</span> <span class="fl">-mtime</span> +<span class="st">"$LOG_MAX_AGE"</span> <span class="fl">-delete</span> <span class="fl">-print</span> | <span class="fn">wc</span> <span class="fl">-l</span>)
    log <span class="st">"Удалено старых логов: $deleted"</span>

    <span class="cm"># Сжать логи старше 1 дня (которые ещё не сжаты):</span>
    <span class="kw">local</span> compressed=<span class="fl">0</span>
    <span class="kw">while</span> <span class="fn">IFS</span>= <span class="fn">read</span> <span class="fl">-r</span> <span class="fl">-d</span> <span class="st">''</span> file; <span class="kw">do</span>
        <span class="fn">gzip</span> <span class="st">"$file"</span>
        ((compressed++)) || <span class="kw">true</span>
    <span class="kw">done</span> &lt; &lt;(<span class="fn">find</span> <span class="st">"$LOG_DIR"</span> <span class="fl">-name</span> <span class="st">"*.log"</span> <span class="fl">-mtime</span> +1 <span class="fl">-print0</span>)
    log <span class="st">"Сжато логов: $compressed"</span>
}
</pre>
                </div>
            </div>

            <div class="step">
                <div class="step-num">Шаг 3 — Основной скрипт (Bash)</div>
                <p>Объединяем проверки и вызываем Python-скрипт для отправки алерта.</p>
                <div class="code-block">
                    <div class="code-header">monitor.sh — часть 3 (main)</div>
<pre>
<span class="cm"># Очистка при выходе:</span>
<span class="kw">TMPFILE</span>=$(<span class="fn">mktemp</span>)
<span class="kw">trap</span> <span class="st">"rm -f $TMPFILE"</span> EXIT

<span class="cm"># Основная логика:</span>
<span class="kw">main</span>() {
    log <span class="st">"===== Запуск мониторинга ====="</span>

    <span class="cm"># 1. Проверка диска:</span>
    <span class="kw">disk_alerts</span>=$(<span class="fn">check_disk</span>)

    <span class="cm"># 2. Ротация логов:</span>
    <span class="fn">rotate_logs</span>

    <span class="cm"># 3. Отправка алерта если есть проблемы:</span>
    <span class="kw">if</span> [ <span class="fl">-n</span> <span class="st">"$disk_alerts"</span> ]; <span class="kw">then</span>
        log <span class="st">"Обнаружены проблемы, отправляю алерт..."</span>

        <span class="cm"># Формируем сообщение:</span>
        <span class="fn">cat</span> &lt;&lt;<span class="kw">EOF</span> &gt; <span class="st">"$TMPFILE"</span>
<span class="st">Сервер: $(hostname)
Дата: $(date '+%Y-%m-%d %H:%M:%S')

Проблемы с дисковым пространством:
$(echo -e "$disk_alerts")</span>
<span class="kw">EOF</span>

        <span class="cm"># Вызываем Python для отправки в Telegram:</span>
        <span class="fn">python3</span> <span class="st">"$ALERT_SCRIPT"</span> <span class="st">"$TMPFILE"</span>
    <span class="kw">else</span>
        log <span class="st">"Всё в порядке, алертов нет."</span>
    <span class="kw">fi</span>

    log <span class="st">"===== Мониторинг завершён ====="</span>
}

main <span class="st">"$@"</span>
</pre>
                </div>
            </div>

            <div class="step">
                <div class="step-num">Шаг 4 — Отправка в Telegram (Python)</div>
                <p>Python-скрипт читает файл с сообщением и отправляет его через Telegram Bot API. Для этого нужен бот (создаётся через <code>@BotFather</code>) и ID чата.</p>
                <div class="code-block">
                    <div class="code-header">alert.py</div>
<pre>
<span class="cm">#!/usr/bin/env python3</span>
<span class="st">"""Отправка алертов в Telegram."""</span>

<span class="kw">import</span> sys
<span class="kw">import</span> os
<span class="kw">import</span> requests

<span class="cm"># Конфигурация через переменные окружения:</span>
<span class="kw">TELEGRAM_BOT_TOKEN</span> = os.environ.<span class="fn">get</span>(<span class="st">"TELEGRAM_BOT_TOKEN"</span>)
<span class="kw">TELEGRAM_CHAT_ID</span> = os.environ.<span class="fn">get</span>(<span class="st">"TELEGRAM_CHAT_ID"</span>)
<span class="kw">TELEGRAM_API</span> = <span class="st">f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}"</span>


<span class="kw">def</span> <span class="fn">send_telegram_message</span>(text: str) -&gt; <span class="fl">bool</span>:
    <span class="st">"""Отправить сообщение в Telegram-чат."""</span>
    <span class="kw">if not</span> TELEGRAM_BOT_TOKEN <span class="kw">or not</span> TELEGRAM_CHAT_ID:
        <span class="fn">print</span>(<span class="st">"TELEGRAM_BOT_TOKEN и TELEGRAM_CHAT_ID не заданы!"</span>,
              file=sys.stderr)
        <span class="kw">return</span> <span class="fl">False</span>

    <span class="kw">try</span>:
        response = requests.<span class="fn">post</span>(
            <span class="st">f"{TELEGRAM_API}/sendMessage"</span>,
            json={
                <span class="st">"chat_id"</span>: TELEGRAM_CHAT_ID,
                <span class="st">"text"</span>: text,
                <span class="st">"parse_mode"</span>: <span class="st">"HTML"</span>,
            },
            timeout=<span class="fl">10</span>,
        )
        response.<span class="fn">raise_for_status</span>()
        <span class="fn">print</span>(<span class="st">"Алерт отправлен в Telegram"</span>)
        <span class="kw">return</span> <span class="fl">True</span>

    <span class="kw">except</span> requests.RequestException <span class="kw">as</span> e:
        <span class="fn">print</span>(<span class="st">f"Ошибка отправки в Telegram: {e}"</span>, file=sys.stderr)
        <span class="kw">return</span> <span class="fl">False</span>


<span class="kw">def</span> <span class="fn">main</span>():
    <span class="kw">if</span> <span class="fn">len</span>(sys.argv) &lt; <span class="fl">2</span>:
        <span class="fn">print</span>(<span class="st">f"Использование: {sys.argv[<span class="fl">0</span>]} &lt;файл_с_сообщением&gt;"</span>)
        sys.<span class="fn">exit</span>(<span class="fl">1</span>)

    message_file = sys.argv[<span class="fl">1</span>]

    <span class="kw">try</span>:
        <span class="kw">with</span> <span class="fn">open</span>(message_file, <span class="st">"r"</span>) <span class="kw">as</span> f:
            message = f.<span class="fn">read</span>().strip()
    <span class="kw">except</span> FileNotFoundError:
        <span class="fn">print</span>(<span class="st">f"Файл не найден: {message_file}"</span>, file=sys.stderr)
        sys.<span class="fn">exit</span>(<span class="fl">1</span>)

    <span class="cm"># Оборачиваем в HTML для моноширинного отображения:</span>
    formatted = <span class="st">f"&lt;b&gt;ALERT: Disk Space&lt;/b&gt;\n\n&lt;pre&gt;{message}&lt;/pre&gt;"</span>

    <span class="kw">if not</span> <span class="fn">send_telegram_message</span>(formatted):
        sys.<span class="fn">exit</span>(<span class="fl">1</span>)


<span class="kw">if</span> __name__ == <span class="st">"__main__"</span>:
    <span class="fn">main</span>()
</pre>
                </div>
            </div>

            <div class="step">
                <div class="step-num">Шаг 5 — Запуск по расписанию</div>
                <p>Настраиваем cron для автоматического запуска каждые 30 минут.</p>
                <div class="code-block">
                    <div class="code-header">terminal — установка и настройка</div>
<pre>
<span class="cm"># Установить зависимости Python:</span>
<span class="fn">python3</span> <span class="fl">-m</span> venv /opt/monitor/.venv
<span class="fn">source</span> /opt/monitor/.venv/bin/activate
<span class="fn">pip</span> install requests

<span class="cm"># Задать переменные окружения (в /etc/environment или .env файл):</span>
<span class="fn">export</span> <span class="kw">TELEGRAM_BOT_TOKEN</span>=<span class="st">"123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11"</span>
<span class="fn">export</span> <span class="kw">TELEGRAM_CHAT_ID</span>=<span class="st">"-1001234567890"</span>

<span class="cm"># Сделать скрипты исполняемыми:</span>
<span class="fn">chmod</span> +x /opt/monitor/monitor.sh
<span class="fn">chmod</span> +x /opt/monitor/alert.py

<span class="cm"># Добавить в crontab:</span>
<span class="fn">crontab</span> <span class="fl">-e</span>
</pre>
                </div>
                <div class="code-block">
                    <div class="code-header">crontab</div>
<pre>
<span class="kw">PATH</span>=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
<span class="kw">TELEGRAM_BOT_TOKEN</span>=123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11
<span class="kw">TELEGRAM_CHAT_ID</span>=-1001234567890

<span class="cm"># Мониторинг каждые 30 минут:</span>
*/30 * * * *  /opt/monitor/.venv/bin/python3 -c "" && /opt/monitor/monitor.sh &gt;&gt; /var/log/monitor.log 2&gt;&amp;1
</pre>
                </div>
            </div>

            <!-- ===== PRACTICE ===== -->
            <div class="practice">
                <h3>Практика</h3>
                <ol>
                    <li><strong>Bash: Анализатор логов.</strong> Напишите скрипт, который принимает файл access-лога nginx, выводит топ-10 IP-адресов по количеству запросов, топ-5 запрашиваемых URL и количество ответов с кодами 4xx и 5xx. Используйте <code>awk</code>, <code>sort</code>, <code>uniq</code>, <code>head</code>.</li>
                    <li><strong>Bash: Менеджер бэкапов.</strong> Создайте скрипт с <code>getopts</code>, который принимает флаги <code>-s</code> (исходная директория), <code>-d</code> (директория бэкапов), <code>-r</code> (количество сохраняемых копий). Скрипт должен создавать tar.gz-архив, удалять старые копии сверх лимита и выводить отчёт.</li>
                    <li><strong>Python: Инвентаризация серверов.</strong> Напишите скрипт, который читает YAML-файл с описанием серверов (hostname, ip, role, environment), фильтрует по окружению (аргумент командной строки) и выводит результат в виде отформатированной таблицы.</li>
                    <li><strong>Python: Health-checker.</strong> Создайте скрипт, который принимает список URL из файла, асинхронно проверяет доступность каждого (GET-запрос, таймаут 5 сек), и выводит отчёт: URL, код ответа, время ответа в мс. Используйте <code>requests</code> и <code>concurrent.futures.ThreadPoolExecutor</code>.</li>
                    <li><strong>Bash + Python: CI pipeline локально.</strong> Напишите Bash-скрипт, который клонирует git-репозиторий, запускает линтер (shellcheck для .sh, flake8 для .py), запускает тесты (pytest), и при ошибке вызывает Python-скрипт для отправки уведомления в Slack (через webhook). Добавьте в cron для запуска каждый час.</li>
                </ol>
            </div>

            <!-- ===== RESOURCES ===== -->
            <div class="resources">
                <h3>Ресурсы</h3>
                <ul>
                    <li>
                        <a href="https://www.gnu.org/software/bash/manual/bash.html" target="_blank">GNU Bash Reference Manual</a>
                        <div class="res-desc">Официальная документация Bash. Полный справочник по синтаксису, встроенным командам и возможностям оболочки.</div>
                    </li>
                    <li>
                        <a href="https://docs.python.org/3/" target="_blank">Python 3 Documentation</a>
                        <div class="res-desc">Официальная документация Python. Стандартная библиотека, туториалы, справочник по языку.</div>
                    </li>
                    <li>
                        <a href="https://www.shellcheck.net/" target="_blank">ShellCheck</a>
                        <div class="res-desc">Статический анализатор Bash-скриптов. Находит ошибки, проблемы с переносимостью и предлагает исправления. Обязателен к использованию.</div>
                    </li>
                    <li>
                        <a href="https://mywiki.wooledge.org/BashGuide" target="_blank">Wooledge Bash Guide</a>
                        <div class="res-desc">Подробное руководство по Bash от сообщества. Отлично объясняет подводные камни и лучшие практики.</div>
                    </li>
                    <li>
                        <a href="https://realpython.com/" target="_blank">Real Python</a>
                        <div class="res-desc">Качественные туториалы по Python с фокусом на практическое применение. Много материалов по автоматизации и DevOps.</div>
                    </li>
                </ul>
            </div>

            <!-- ===== MARK COMPLETE ===== -->
            <label class="mark-complete">
                <input type="checkbox" id="topicCheckbox" data-topic="scripting">
                <span>Отметить тему как изученную</span>
            </label>

            <!-- ===== BOTTOM NAV ===== -->
            <div class="bottom-nav">
                <a href="git.html" class="prev">
                    <div class="nav-label">Назад</div>
                    <div class="nav-title">Git</div>
                </a>
                <a href="nginx.html" class="next">
                    <div class="nav-label">Далее</div>
                    <div class="nav-title">Nginx</div>
                </a>
            </div>

        </div>
    </main>
    <script src="../app.js"></script>
</body>
</html>