<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Сети — DevOps Roadmap</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header class="header">
        <div class="container">
            <a href="../index.html" class="header-logo">&larr; DevOps Roadmap</a>
            <span class="header-title">Сети</span>
            <span class="header-progress" id="headerProgress"></span>
        </div>
    </header>
    <main class="container">
        <div class="page-content">

            <!-- ===== ЗАГОЛОВОК ===== -->
            <h1>Сети</h1>
            <p class="subtitle">Понимание сетевых технологий &mdash; фундаментальный навык для DevOps-инженера. Без глубокого знания того, как данные передаются между системами, невозможно эффективно проектировать, развёртывать и отлаживать современные распределённые приложения.</p>

            <!-- ===== ВВЕДЕНИЕ ===== -->
            <div class="section">
                <p class="section-label">Основы</p>
                <h2>Введение</h2>

                <p>Каждый сервис, который вы развёртываете, каждый контейнер, каждая виртуальная машина &mdash; все они общаются между собой через сеть. Когда пользователь открывает веб-страницу, его запрос проходит через десятки сетевых узлов, DNS-серверов, балансировщиков нагрузки и файрволов, прежде чем достигнет целевого сервера. DevOps-инженер должен понимать каждый этап этого пути, чтобы быстро находить и устранять проблемы.</p>

                <p>Практически все типичные задачи DevOps так или иначе связаны с сетью: настройка обратного прокси-сервера, конфигурация правил файрвола, отладка проблем с DNS, организация безопасного доступа через SSH, настройка VPN-туннелей между облачными провайдерами. Без твёрдого понимания сетевых протоколов и моделей эти задачи превращаются в гадание по логам и бездумное копирование конфигов из интернета.</p>

                <p>В этом разделе мы подробно рассмотрим все ключевые аспекты сетей: от базовых моделей OSI и TCP/IP до прикладных протоколов HTTP, DNS и SSH. Мы разберём IP-адресацию, подсети, файрволы и завершим практическим туториалом по настройке Nginx с SSL-сертификатом. Цель &mdash; дать вам системное понимание сетевых технологий, достаточное для уверенной работы в реальных DevOps-проектах.</p>
            </div>

            <!-- ===== МОДЕЛЬ OSI И TCP/IP ===== -->
            <div class="section">
                <p class="section-label">Теоретическая база</p>
                <h2>Модель OSI и TCP/IP</h2>

                <p>Модель OSI (Open Systems Interconnection) &mdash; это эталонная модель, описывающая взаимодействие сетевых систем на семи уровнях абстракции. Она была разработана Международной организацией по стандартизации (ISO) в 1984 году и служит универсальным языком для описания сетевых процессов. Каждый уровень выполняет строго определённую функцию и взаимодействует только с соседними уровнями: принимает данные от верхнего и передаёт обработанные данные нижнему.</p>

                <p>На практике в интернете используется модель TCP/IP, которая состоит из четырёх уровней и является упрощённой версией OSI. Модель TCP/IP объединяет несколько уровней OSI в один: например, уровни представления и сеансовый объединены с прикладным. Несмотря на это, знание модели OSI остаётся критически важным для DevOps-инженера, поскольку она позволяет точно локализовать проблему при отладке: если пинг проходит, но HTTP-запрос не работает, вы знаете, что проблема выше третьего уровня.</p>

                <p>Ключевая концепция обеих моделей &mdash; <strong>инкапсуляция</strong>. Когда приложение отправляет данные, каждый уровень добавляет свой заголовок (а иногда и трейлер) к пакету данных. На прикладном уровне это HTTP-заголовки, на транспортном &mdash; TCP-заголовок с номерами портов, на сетевом &mdash; IP-заголовок с адресами, на канальном &mdash; MAC-адреса и контрольная сумма. При получении данных процесс идёт в обратном порядке: каждый уровень снимает свой заголовок и передаёт данные выше. Этот процесс называется <strong>декапсуляцией</strong>.</p>

                <h3>Семь уровней OSI</h3>

                <div class="concepts">
                    <div class="concept">
                        <h3>7. Прикладной уровень (Application)</h3>
                        <p>Это уровень, с которым непосредственно взаимодействуют приложения пользователя. Здесь работают протоколы HTTP, HTTPS, FTP, SMTP, DNS, SSH. Когда ваш браузер формирует HTTP-запрос или почтовый клиент отправляет письмо через SMTP &mdash; это происходит на прикладном уровне. DevOps-инженер работает с этим уровнем чаще всего: настройка веб-серверов, отладка API-запросов, анализ заголовков HTTP.</p>
                    </div>

                    <div class="concept">
                        <h3>6. Уровень представления (Presentation)</h3>
                        <p>Отвечает за преобразование данных в формат, понятный приложению: шифрование и дешифрование (TLS/SSL), сжатие данных (gzip), преобразование кодировок (ASCII, UTF-8). Когда вы видите зелёный замочек в браузере &mdash; за шифрование отвечает именно этот уровень. В модели TCP/IP функции этого уровня включены в прикладной.</p>
                    </div>

                    <div class="concept">
                        <h3>5. Сеансовый уровень (Session)</h3>
                        <p>Управляет сеансами связи между приложениями: устанавливает, поддерживает и завершает соединения. Примеры &mdash; NetBIOS, RPC, механизмы аутентификации. В контексте веб-приложений сеансы часто реализуются на прикладном уровне через cookies и токены, но концептуально управление сессиями относится именно сюда.</p>
                    </div>

                    <div class="concept">
                        <h3>4. Транспортный уровень (Transport)</h3>
                        <p>Обеспечивает надёжную (TCP) или ненадёжную (UDP) передачу данных между процессами на разных машинах. Здесь появляются <strong>порты</strong> &mdash; числовые идентификаторы, позволяющие нескольким приложениям на одной машине одновременно использовать сеть. TCP гарантирует доставку, порядок пакетов и контроль потока. UDP просто отправляет данные без гарантий, но быстрее.</p>
                    </div>

                    <div class="concept">
                        <h3>3. Сетевой уровень (Network)</h3>
                        <p>Отвечает за маршрутизацию пакетов между сетями. Основной протокол &mdash; IP (Internet Protocol). На этом уровне работают маршрутизаторы, определяя оптимальный путь для каждого пакета. IP-адреса, подсети, маски &mdash; всё это концепции сетевого уровня. Утилиты <code>ping</code>, <code>traceroute</code> и <code>ip route</code> работают именно здесь.</p>
                    </div>

                    <div class="concept">
                        <h3>2. Канальный уровень (Data Link)</h3>
                        <p>Обеспечивает передачу данных между устройствами в одной локальной сети. Здесь используются MAC-адреса &mdash; уникальные физические адреса сетевых интерфейсов. Протокол ARP преобразует IP-адреса в MAC-адреса. Коммутаторы (switches) работают на этом уровне, направляя кадры (frames) по MAC-адресам. VLAN &mdash; технология виртуальных сетей &mdash; тоже реализуется здесь.</p>
                    </div>

                    <div class="concept">
                        <h3>1. Физический уровень (Physical)</h3>
                        <p>Самый нижний уровень &mdash; передача сырых битов по физической среде: медные кабели (Ethernet), оптоволокно, Wi-Fi радиоволны. Определяет электрические сигналы, разъёмы, скорость передачи. Для DevOps-инженера этот уровень менее актуален, если только вы не работаете с физической инфраструктурой в дата-центре.</p>
                    </div>
                </div>

                <h3>Сравнение моделей OSI и TCP/IP</h3>

                <div class="table-wrap">
                    <table>
                        <thead>
                            <tr>
                                <th>Модель OSI</th>
                                <th>Модель TCP/IP</th>
                                <th>Примеры протоколов</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>7. Прикладной</td>
                                <td rowspan="3">Прикладной</td>
                                <td>HTTP, DNS, SSH, FTP, SMTP</td>
                            </tr>
                            <tr>
                                <td>6. Представления</td>
                                <td>TLS/SSL, JPEG, gzip</td>
                            </tr>
                            <tr>
                                <td>5. Сеансовый</td>
                                <td>NetBIOS, RPC, сокеты</td>
                            </tr>
                            <tr>
                                <td>4. Транспортный</td>
                                <td>Транспортный</td>
                                <td>TCP, UDP</td>
                            </tr>
                            <tr>
                                <td>3. Сетевой</td>
                                <td>Сетевой (Internet)</td>
                                <td>IP, ICMP, ARP</td>
                            </tr>
                            <tr>
                                <td>2. Канальный</td>
                                <td rowspan="2">Канальный (Network Access)</td>
                                <td>Ethernet, Wi-Fi, PPP</td>
                            </tr>
                            <tr>
                                <td>1. Физический</td>
                                <td>Кабели, оптоволокно, радио</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="note">
                    <strong>На заметку:</strong> при диагностике сетевых проблем двигайтесь снизу вверх по модели OSI. Сначала проверьте физическое подключение (кабель, Wi-Fi), затем IP-связность (<code>ping</code>), затем доступность порта (<code>telnet</code>, <code>nc</code>), и наконец прикладной уровень (<code>curl</code>).
                </div>
            </div>

            <!-- ===== IP-АДРЕСАЦИЯ ===== -->
            <div class="section">
                <p class="section-label">Адресация</p>
                <h2>IP-адресация и подсети</h2>

                <p>IP-адрес &mdash; это уникальный числовой идентификатор устройства в сети. В версии IPv4 адрес представлен четырьмя октетами (байтами), разделёнными точками, например: <code>192.168.1.100</code>. Каждый октет может принимать значение от 0 до 255, что даёт общее адресное пространство около 4,3 миллиарда адресов. Этого количества уже давно не хватает для всех устройств в мире, поэтому используются технологии NAT и постепенно внедряется IPv6.</p>

                <p>IP-адреса делятся на <strong>публичные</strong> и <strong>частные</strong>. Публичные адреса маршрутизируются в интернете и уникальны глобально. Частные адреса используются только внутри локальных сетей и не маршрутизируются в интернете. Стандарт RFC 1918 определяет три диапазона частных адресов: <code>10.0.0.0/8</code> (от 10.0.0.0 до 10.255.255.255 &mdash; более 16 миллионов адресов), <code>172.16.0.0/12</code> (от 172.16.0.0 до 172.31.255.255 &mdash; около миллиона адресов) и <code>192.168.0.0/16</code> (от 192.168.0.0 до 192.168.255.255 &mdash; более 65 тысяч адресов). Именно эти адреса вы видите в домашних сетях и в облачных VPC.</p>

                <p><strong>Маска подсети</strong> определяет, какая часть IP-адреса относится к сети, а какая &mdash; к хосту. Например, маска <code>255.255.255.0</code> (или <code>/24</code> в нотации CIDR) означает, что первые 24 бита &mdash; это адрес сети, а последние 8 бит &mdash; адрес хоста в этой сети. Подсеть <code>192.168.1.0/24</code> включает адреса от 192.168.1.0 (адрес сети) до 192.168.1.255 (широковещательный адрес), при этом для хостов доступны адреса от 192.168.1.1 до 192.168.1.254, то есть 254 хоста.</p>

                <h3>Нотация CIDR</h3>

                <p>CIDR (Classless Inter-Domain Routing) &mdash; современный способ записи IP-адресов с указанием длины префикса сети. Число после слеша обозначает количество единичных битов в маске. Чем больше это число, тем меньше хостов в подсети. Формула расчёта количества доступных хостов: <strong>2^(32 - prefix) - 2</strong> (вычитаем адрес сети и широковещательный адрес).</p>

                <div class="table-wrap">
                    <table>
                        <thead>
                            <tr>
                                <th>CIDR</th>
                                <th>Маска</th>
                                <th>Адресов</th>
                                <th>Хостов</th>
                                <th>Применение</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>/8</code></td>
                                <td>255.0.0.0</td>
                                <td>16 777 216</td>
                                <td>16 777 214</td>
                                <td>Крупные корпоративные сети</td>
                            </tr>
                            <tr>
                                <td><code>/16</code></td>
                                <td>255.255.0.0</td>
                                <td>65 536</td>
                                <td>65 534</td>
                                <td>Облачные VPC</td>
                            </tr>
                            <tr>
                                <td><code>/24</code></td>
                                <td>255.255.255.0</td>
                                <td>256</td>
                                <td>254</td>
                                <td>Типичная подсеть</td>
                            </tr>
                            <tr>
                                <td><code>/28</code></td>
                                <td>255.255.255.240</td>
                                <td>16</td>
                                <td>14</td>
                                <td>Маленькие подсети, DMZ</td>
                            </tr>
                            <tr>
                                <td><code>/32</code></td>
                                <td>255.255.255.255</td>
                                <td>1</td>
                                <td>1</td>
                                <td>Один конкретный хост</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Пример расчёта подсети</h3>

                <div class="code-block">
                    <div class="code-header">Расчёт подсети 10.0.1.0/24</div>
                    <pre><code><span class="cm"># Дано: 10.0.1.0/24</span>
<span class="cm"># Prefix = 24, значит 32 - 24 = 8 бит на хосты</span>
<span class="cm"># 2^8 = 256 адресов, 256 - 2 = 254 хоста</span>

Адрес сети:           10.0.1.0
Первый хост:          10.0.1.1
Последний хост:       10.0.1.254
Широковещательный:    10.0.1.255
Маска:                255.255.255.0

<span class="cm"># Проверка с помощью утилиты ipcalc:</span>
<span class="fn">ipcalc</span> 10.0.1.0/24</code></pre>
                </div>

                <h3>IPv6</h3>

                <p>IPv6 &mdash; следующее поколение протокола IP с 128-битными адресами (против 32-битных в IPv4). Это даёт колоссальное адресное пространство: 2^128 адресов. Адрес записывается в виде восьми групп по четыре шестнадцатеричные цифры, разделённых двоеточиями: <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>. Нулевые группы можно сокращать: <code>2001:db8:85a3::8a2e:370:7334</code>. В DevOps IPv6 становится всё более актуальным, особенно при работе с Kubernetes и облачными сервисами, которые поддерживают dual-stack (IPv4 + IPv6).</p>

                <div class="note">
                    <strong>Для DevOps:</strong> при проектировании сетей в облаке (AWS VPC, GCP VPC) выбор CIDR-блока &mdash; одно из первых решений. Используйте <code>/16</code> для VPC и <code>/24</code> для подсетей. Планируйте адресное пространство заранее, так как изменить CIDR существующего VPC невозможно.
                </div>
            </div>

            <!-- ===== TCP И UDP ===== -->
            <div class="section">
                <p class="section-label">Транспортные протоколы</p>
                <h2>TCP и UDP</h2>

                <p><strong>TCP (Transmission Control Protocol)</strong> &mdash; протокол транспортного уровня, обеспечивающий надёжную, упорядоченную и проверенную доставку данных. Перед началом передачи данных TCP устанавливает соединение с помощью механизма, называемого <strong>трёхэтапное рукопожатие</strong> (3-way handshake). Этот процесс состоит из трёх шагов: клиент отправляет пакет с флагом SYN (synchronize), сервер отвечает пакетом SYN-ACK (synchronize-acknowledge), и клиент завершает установку соединения пакетом ACK (acknowledge). Только после этого начинается передача данных.</p>

                <p>TCP гарантирует доставку данных за счёт нескольких механизмов. <strong>Подтверждения (ACK)</strong>: получатель подтверждает каждый полученный сегмент; если отправитель не получает подтверждение в течение таймаута, он повторно отправляет данные. <strong>Порядок пакетов</strong>: каждый сегмент имеет порядковый номер (sequence number), что позволяет получателю собрать данные в правильном порядке, даже если пакеты пришли не по порядку. <strong>Контроль потока (flow control)</strong>: механизм скользящего окна (sliding window) позволяет получателю сообщить отправителю, сколько данных он готов принять, предотвращая переполнение буфера. <strong>Контроль перегрузки (congestion control)</strong>: TCP динамически регулирует скорость передачи в зависимости от состояния сети.</p>

                <p><strong>UDP (User Datagram Protocol)</strong> &mdash; протокол без установления соединения. UDP не гарантирует ни доставку, ни порядок пакетов, ни отсутствие дубликатов. Зато он значительно быстрее TCP, так как не тратит время на рукопожатие, подтверждения и повторные отправки. UDP используется там, где скорость важнее надёжности: DNS-запросы (обычно помещаются в один пакет), потоковое видео и аудио (лучше пропустить кадр, чем задержать поток), онлайн-игры (актуально только последнее состояние), мониторинг (SNMP), VPN (WireGuard работает поверх UDP).</p>

                <h3>Трёхэтапное рукопожатие TCP</h3>

                <div class="code-block">
                    <div class="code-header">TCP 3-way handshake</div>
                    <pre><code><span class="cm">Клиент                          Сервер</span>
<span class="cm">   |                               |</span>
<span class="cm">   |</span>  <span class="kw">--- SYN (seq=100) ----------></span>  <span class="cm">|   1. Клиент хочет соединиться</span>
<span class="cm">   |                               |</span>
<span class="cm">   |</span>  <span class="kw"><-- SYN-ACK (seq=300,ack=101)</span> <span class="cm">|   2. Сервер подтверждает и</span>
<span class="cm">   |                               |      отправляет свой SYN</span>
<span class="cm">   |</span>  <span class="kw">--- ACK (ack=301) ----------></span>  <span class="cm">|   3. Клиент подтверждает</span>
<span class="cm">   |                               |</span>
<span class="cm">   |</span>  <span class="st">===== СОЕДИНЕНИЕ УСТАНОВЛЕНО =====</span>
<span class="cm">   |                               |</span>
<span class="cm">   |</span>  <span class="kw">--- данные ---------------></span>   <span class="cm">|   Передача данных</span>
<span class="cm">   |</span>  <span class="kw"><-- ACK -------------------</span>   <span class="cm">|   Подтверждение</span>
<span class="cm">   |                               |</span></code></pre>
                </div>

                <h3>Сравнение TCP и UDP</h3>

                <div class="table-wrap">
                    <table>
                        <thead>
                            <tr>
                                <th>Характеристика</th>
                                <th>TCP</th>
                                <th>UDP</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Соединение</td>
                                <td>С установлением (3-way handshake)</td>
                                <td>Без установления</td>
                            </tr>
                            <tr>
                                <td>Надёжность</td>
                                <td>Гарантированная доставка</td>
                                <td>Без гарантий</td>
                            </tr>
                            <tr>
                                <td>Порядок пакетов</td>
                                <td>Гарантирован</td>
                                <td>Не гарантирован</td>
                            </tr>
                            <tr>
                                <td>Скорость</td>
                                <td>Медленнее (накладные расходы)</td>
                                <td>Быстрее</td>
                            </tr>
                            <tr>
                                <td>Контроль потока</td>
                                <td>Есть (sliding window)</td>
                                <td>Нет</td>
                            </tr>
                            <tr>
                                <td>Применение</td>
                                <td>HTTP, SSH, FTP, SMTP, базы данных</td>
                                <td>DNS, видео, VoIP, игры, VPN</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="code-block">
                    <div class="code-header">Диагностика TCP-соединений</div>
                    <pre><code><span class="cm"># Проверить открытые TCP-соединения</span>
<span class="fn">ss</span> <span class="fl">-tuln</span>

<span class="cm"># Проверить доступность TCP-порта на удалённом хосте</span>
<span class="fn">nc</span> <span class="fl">-zv</span> <span class="st">example.com</span> <span class="fl">443</span>

<span class="cm"># Отследить TCP-рукопожатие с помощью tcpdump</span>
<span class="fn">sudo</span> <span class="fn">tcpdump</span> <span class="fl">-i eth0</span> <span class="st">'tcp[tcpflags] & (tcp-syn|tcp-ack) != 0'</span> <span class="fl">-n</span>

<span class="cm"># Проверить состояния TCP-соединений</span>
<span class="fn">ss</span> <span class="fl">-s</span>
<span class="cm"># Покажет количество соединений в состояниях:</span>
<span class="cm"># ESTABLISHED, TIME_WAIT, CLOSE_WAIT и т.д.</span></code></pre>
                </div>

                <div class="note">
                    <strong>Частая проблема:</strong> если вы видите множество соединений в состоянии <code>TIME_WAIT</code>, это может указывать на неэффективное использование соединений. Рассмотрите использование HTTP keep-alive или connection pooling.
                </div>
            </div>

            <!-- ===== DNS ===== -->
            <div class="section">
                <p class="section-label">Система имён</p>
                <h2>DNS</h2>

                <p><strong>DNS (Domain Name System)</strong> &mdash; это распределённая иерархическая система, которая переводит человекочитаемые доменные имена (например, <code>example.com</code>) в IP-адреса (например, <code>93.184.216.34</code>). DNS часто называют &laquo;телефонной книгой интернета&raquo;. Без DNS пользователям пришлось бы запоминать IP-адреса каждого сайта. Для DevOps-инженера DNS &mdash; одна из наиболее часто отлаживаемых систем: неправильная настройка DNS-записей является причиной огромного числа инцидентов.</p>

                <p>Процесс разрешения DNS-имени (DNS resolution) включает несколько этапов. Когда вы вводите <code>example.com</code> в браузере, сначала проверяется локальный кеш браузера, затем кеш операционной системы (и файл <code>/etc/hosts</code>). Если имя не найдено, запрос отправляется к <strong>рекурсивному резолверу</strong> (обычно это DNS-сервер вашего провайдера или публичный DNS вроде 8.8.8.8). Резолвер проверяет свой кеш, и если записи нет, начинает итеративный процесс: обращается к <strong>корневому DNS-серверу</strong> (один из 13 групп корневых серверов), который указывает на сервер <strong>домена верхнего уровня (TLD)</strong> &mdash; например, сервер зоны <code>.com</code>. TLD-сервер направляет к <strong>авторитативному DNS-серверу</strong> домена <code>example.com</code>, который и возвращает конечный IP-адрес.</p>

                <p>Каждая DNS-запись имеет параметр <strong>TTL (Time To Live)</strong> &mdash; время в секундах, в течение которого запись может кешироваться. Высокий TTL (например, 86400 &mdash; сутки) снижает нагрузку на DNS-серверы, но при изменении IP-адреса обновление займёт больше времени. Низкий TTL (например, 60 &mdash; одна минута) позволяет быстро переключать трафик, что полезно при миграциях, но увеличивает количество DNS-запросов. Перед миграцией рекомендуется заранее снизить TTL до минимума, выполнить переключение, а затем вернуть высокий TTL.</p>

                <h3>Типы DNS-записей</h3>

                <div class="table-wrap">
                    <table>
                        <thead>
                            <tr>
                                <th>Тип</th>
                                <th>Назначение</th>
                                <th>Пример</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>A</code></td>
                                <td>Связывает домен с IPv4-адресом</td>
                                <td><code>example.com &rarr; 93.184.216.34</code></td>
                            </tr>
                            <tr>
                                <td><code>AAAA</code></td>
                                <td>Связывает домен с IPv6-адресом</td>
                                <td><code>example.com &rarr; 2606:2800:220:1:...</code></td>
                            </tr>
                            <tr>
                                <td><code>CNAME</code></td>
                                <td>Псевдоним &mdash; указывает на другое доменное имя</td>
                                <td><code>www.example.com &rarr; example.com</code></td>
                            </tr>
                            <tr>
                                <td><code>MX</code></td>
                                <td>Почтовый сервер для домена (с приоритетом)</td>
                                <td><code>example.com &rarr; 10 mail.example.com</code></td>
                            </tr>
                            <tr>
                                <td><code>TXT</code></td>
                                <td>Произвольный текст (SPF, DKIM, верификация)</td>
                                <td><code>"v=spf1 include:_spf.google.com ~all"</code></td>
                            </tr>
                            <tr>
                                <td><code>NS</code></td>
                                <td>Авторитативные DNS-серверы для зоны</td>
                                <td><code>example.com &rarr; ns1.dnsprovider.com</code></td>
                            </tr>
                            <tr>
                                <td><code>SOA</code></td>
                                <td>Начало зоны: основной NS, email администратора, серийный номер</td>
                                <td>Содержит параметры зоны</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Инструменты диагностики DNS</h3>

                <div class="code-block">
                    <div class="code-header">nslookup</div>
                    <pre><code><span class="cm"># Базовый запрос A-записи</span>
<span class="fn">nslookup</span> <span class="st">example.com</span>

<span class="cm"># Запрос конкретного типа записи</span>
<span class="fn">nslookup</span> <span class="fl">-type=MX</span> <span class="st">example.com</span>

<span class="cm"># Запрос к определённому DNS-серверу</span>
<span class="fn">nslookup</span> <span class="st">example.com</span> <span class="st">8.8.8.8</span></code></pre>
                </div>

                <div class="code-block">
                    <div class="code-header">dig (более мощный инструмент)</div>
                    <pre><code><span class="cm"># Полный запрос с детальной информацией</span>
<span class="fn">dig</span> <span class="st">example.com</span>

<span class="cm"># Запрос конкретного типа записи</span>
<span class="fn">dig</span> <span class="st">example.com</span> <span class="fl">MX</span>

<span class="cm"># Только ответ, без лишней информации</span>
<span class="fn">dig</span> <span class="fl">+short</span> <span class="st">example.com</span>

<span class="cm"># Проследить полный путь разрешения DNS</span>
<span class="fn">dig</span> <span class="fl">+trace</span> <span class="st">example.com</span>

<span class="cm"># Запрос к конкретному DNS-серверу</span>
<span class="fn">dig</span> <span class="fl">@8.8.8.8</span> <span class="st">example.com</span>

<span class="cm"># Обратный DNS-запрос (IP → имя)</span>
<span class="fn">dig</span> <span class="fl">-x</span> <span class="st">93.184.216.34</span></code></pre>
                </div>

                <div class="note">
                    <strong>Совет:</strong> команда <code>dig +trace example.com</code> покажет весь путь разрешения DNS-имени от корневых серверов до авторитативного сервера. Это незаменимый инструмент для диагностики проблем с DNS-пропагацией.
                </div>
            </div>

            <!-- ===== HTTP И HTTPS ===== -->
            <div class="section">
                <p class="section-label">Прикладные протоколы</p>
                <h2>HTTP и HTTPS</h2>

                <p><strong>HTTP (HyperText Transfer Protocol)</strong> &mdash; основной протокол передачи данных в вебе. Он работает по модели &laquo;запрос-ответ&raquo;: клиент (браузер, curl, API-клиент) отправляет HTTP-запрос, а сервер возвращает HTTP-ответ. Каждый запрос содержит <strong>метод</strong> (GET, POST и т.д.), <strong>URI</strong> (путь к ресурсу), <strong>заголовки</strong> (метаданные запроса) и, опционально, <strong>тело</strong> (данные запроса). HTTP &mdash; это текстовый протокол без состояния: каждый запрос обрабатывается независимо, сервер не помнит предыдущие запросы (для сохранения состояния используются cookies и токены).</p>

                <p><strong>HTTPS</strong> &mdash; это HTTP, защищённый протоколом TLS (Transport Layer Security). HTTPS обеспечивает три ключевых свойства: <strong>конфиденциальность</strong> (данные зашифрованы и не могут быть прочитаны третьими лицами), <strong>целостность</strong> (данные не могут быть незаметно изменены при передаче) и <strong>аутентификация</strong> (клиент может удостовериться, что общается именно с тем сервером, за который тот себя выдаёт). Сегодня HTTPS является стандартом: браузеры помечают HTTP-сайты как &laquo;небезопасные&raquo;, а поисковые системы отдают приоритет HTTPS-сайтам.</p>

                <p>При установке TLS-соединения происходит <strong>TLS-рукопожатие</strong> (TLS handshake). Клиент отправляет ClientHello с поддерживаемыми шифрами. Сервер отвечает ServerHello, выбирая шифр, и отправляет свой SSL-сертификат. Клиент проверяет сертификат по цепочке доверия (Certificate Authority). Затем стороны обмениваются ключами (обычно через алгоритм Diffie-Hellman) и устанавливают симметричное шифрование для дальнейшей передачи данных. Асимметричная криптография используется только на этапе рукопожатия, а сами данные шифруются быстрыми симметричными алгоритмами (AES).</p>

                <h3>HTTP-методы</h3>

                <div class="table-wrap">
                    <table>
                        <thead>
                            <tr>
                                <th>Метод</th>
                                <th>Назначение</th>
                                <th>Идемпотентный</th>
                                <th>Тело запроса</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>GET</code></td>
                                <td>Получить ресурс</td>
                                <td>Да</td>
                                <td>Нет</td>
                            </tr>
                            <tr>
                                <td><code>POST</code></td>
                                <td>Создать ресурс / отправить данные</td>
                                <td>Нет</td>
                                <td>Да</td>
                            </tr>
                            <tr>
                                <td><code>PUT</code></td>
                                <td>Полностью заменить ресурс</td>
                                <td>Да</td>
                                <td>Да</td>
                            </tr>
                            <tr>
                                <td><code>PATCH</code></td>
                                <td>Частично обновить ресурс</td>
                                <td>Нет</td>
                                <td>Да</td>
                            </tr>
                            <tr>
                                <td><code>DELETE</code></td>
                                <td>Удалить ресурс</td>
                                <td>Да</td>
                                <td>Обычно нет</td>
                            </tr>
                            <tr>
                                <td><code>HEAD</code></td>
                                <td>Получить только заголовки (без тела)</td>
                                <td>Да</td>
                                <td>Нет</td>
                            </tr>
                            <tr>
                                <td><code>OPTIONS</code></td>
                                <td>Узнать поддерживаемые методы (CORS preflight)</td>
                                <td>Да</td>
                                <td>Нет</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Коды состояния HTTP</h3>

                <div class="table-wrap">
                    <table>
                        <thead>
                            <tr>
                                <th>Диапазон</th>
                                <th>Категория</th>
                                <th>Примеры</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>1xx</code></td>
                                <td>Информационные</td>
                                <td><code>100 Continue</code>, <code>101 Switching Protocols</code></td>
                            </tr>
                            <tr>
                                <td><code>2xx</code></td>
                                <td>Успех</td>
                                <td><code>200 OK</code>, <code>201 Created</code>, <code>204 No Content</code></td>
                            </tr>
                            <tr>
                                <td><code>3xx</code></td>
                                <td>Перенаправление</td>
                                <td><code>301 Moved Permanently</code>, <code>302 Found</code>, <code>304 Not Modified</code></td>
                            </tr>
                            <tr>
                                <td><code>4xx</code></td>
                                <td>Ошибка клиента</td>
                                <td><code>400 Bad Request</code>, <code>401 Unauthorized</code>, <code>403 Forbidden</code>, <code>404 Not Found</code>, <code>429 Too Many Requests</code></td>
                            </tr>
                            <tr>
                                <td><code>5xx</code></td>
                                <td>Ошибка сервера</td>
                                <td><code>500 Internal Server Error</code>, <code>502 Bad Gateway</code>, <code>503 Service Unavailable</code>, <code>504 Gateway Timeout</code></td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Важные HTTP-заголовки</h3>

                <div class="code-block">
                    <div class="code-header">Типичные HTTP-заголовки</div>
                    <pre><code><span class="cm"># Заголовки запроса</span>
<span class="kw">Host:</span>            <span class="st">example.com</span>          <span class="cm"># Имя сервера</span>
<span class="kw">User-Agent:</span>      <span class="st">curl/7.68.0</span>          <span class="cm"># Клиент</span>
<span class="kw">Accept:</span>          <span class="st">application/json</span>     <span class="cm"># Ожидаемый формат</span>
<span class="kw">Authorization:</span>   <span class="st">Bearer &lt;token&gt;</span>        <span class="cm"># Аутентификация</span>
<span class="kw">Content-Type:</span>    <span class="st">application/json</span>     <span class="cm"># Тип тела запроса</span>

<span class="cm"># Заголовки ответа</span>
<span class="kw">Content-Type:</span>    <span class="st">text/html; charset=utf-8</span>
<span class="kw">Cache-Control:</span>   <span class="st">max-age=3600</span>         <span class="cm"># Кеширование</span>
<span class="kw">Set-Cookie:</span>      <span class="st">session=abc123</span>       <span class="cm"># Установка cookie</span>
<span class="kw">X-Request-Id:</span>    <span class="st">uuid-here</span>            <span class="cm"># ID запроса (для отладки)</span></code></pre>
                </div>

                <h3>SSL-сертификаты и Let's Encrypt</h3>

                <p><strong>SSL/TLS-сертификат</strong> &mdash; это цифровой документ, подтверждающий владение доменом. Сертификат содержит публичный ключ сервера, имя домена и подпись Certificate Authority (CA). Браузер проверяет эту подпись по встроенному списку доверенных CA. Если подпись валидна &mdash; соединение считается безопасным.</p>

                <p><strong>Let's Encrypt</strong> &mdash; бесплатный автоматизированный центр сертификации, выдающий DV-сертификаты (Domain Validated). Инструмент <code>certbot</code> автоматически получает и обновляет сертификаты. Сертификаты Let's Encrypt действительны 90 дней и автоматически продлеваются через cron или systemd timer. Это стандартный выбор для большинства DevOps-проектов.</p>

                <div class="code-block">
                    <div class="code-header">Работа с HTTP через curl</div>
                    <pre><code><span class="cm"># GET-запрос с выводом заголовков</span>
<span class="fn">curl</span> <span class="fl">-v</span> <span class="st">https://example.com</span>

<span class="cm"># POST-запрос с JSON-данными</span>
<span class="fn">curl</span> <span class="fl">-X POST</span> <span class="fl">-H</span> <span class="st">"Content-Type: application/json"</span> \
     <span class="fl">-d</span> <span class="st">'{"name": "test"}'</span> <span class="st">https://api.example.com/items</span>

<span class="cm"># Проверить SSL-сертификат</span>
<span class="fn">curl</span> <span class="fl">-vI</span> <span class="st">https://example.com</span> <span class="fl">2>&amp;1</span> | <span class="fn">grep</span> <span class="st">"SSL certificate"</span>

<span class="cm"># Скачать файл с отображением прогресса</span>
<span class="fn">curl</span> <span class="fl">-O</span> <span class="fl">-#</span> <span class="st">https://example.com/file.tar.gz</span></code></pre>
                </div>
            </div>

            <!-- ===== SSH ===== -->
            <div class="section">
                <p class="section-label">Удалённый доступ</p>
                <h2>SSH</h2>

                <p><strong>SSH (Secure Shell)</strong> &mdash; криптографический сетевой протокол для безопасного удалённого доступа к системам. SSH шифрует весь трафик между клиентом и сервером, что делает его безопасной заменой устаревших протоколов telnet и rsh, которые передавали данные (включая пароли) открытым текстом. SSH работает на порту 22 по умолчанию и используется практически каждым DevOps-инженером ежедневно: для управления серверами, развёртывания кода, туннелирования трафика и передачи файлов.</p>

                <p>SSH использует <strong>асимметричную криптографию</strong> (пару ключей &mdash; публичный и приватный) для аутентификации. Приватный ключ хранится на клиенте и никогда не передаётся. Публичный ключ размещается на сервере в файле <code>~/.ssh/authorized_keys</code>. При подключении сервер шифрует случайное сообщение публичным ключом; если клиент может расшифровать его приватным ключом &mdash; аутентификация пройдена. Это значительно безопаснее парольной аутентификации, которую рекомендуется отключать на продакшн-серверах.</p>

                <p>Помимо удалённого доступа, SSH предоставляет мощные возможности для <strong>туннелирования</strong> (port forwarding). Локальный проброс порта (<code>ssh -L</code>) позволяет получить доступ к удалённому сервису через локальный порт &mdash; например, подключиться к базе данных, которая доступна только из внутренней сети. Обратный проброс (<code>ssh -R</code>) позволяет сделать локальный сервис доступным на удалённой машине. Динамический проброс (<code>ssh -D</code>) создаёт SOCKS-прокси.</p>

                <h3>Генерация и управление ключами</h3>

                <div class="code-block">
                    <div class="code-header">Работа с SSH-ключами</div>
                    <pre><code><span class="cm"># Генерация ключевой пары Ed25519 (рекомендуется)</span>
<span class="fn">ssh-keygen</span> <span class="fl">-t ed25519</span> <span class="fl">-C</span> <span class="st">"devops@example.com"</span>

<span class="cm"># Генерация RSA-ключа (если Ed25519 не поддерживается)</span>
<span class="fn">ssh-keygen</span> <span class="fl">-t rsa</span> <span class="fl">-b 4096</span> <span class="fl">-C</span> <span class="st">"devops@example.com"</span>

<span class="cm"># Копирование публичного ключа на сервер</span>
<span class="fn">ssh-copy-id</span> <span class="fl">-i</span> <span class="st">~/.ssh/id_ed25519.pub</span> <span class="st">user@server</span>

<span class="cm"># Подключение к серверу</span>
<span class="fn">ssh</span> <span class="st">user@192.168.1.100</span>

<span class="cm"># Подключение с указанием ключа и порта</span>
<span class="fn">ssh</span> <span class="fl">-i</span> <span class="st">~/.ssh/my_key</span> <span class="fl">-p 2222</span> <span class="st">user@server</span></code></pre>
                </div>

                <h3>Конфигурация SSH</h3>

                <div class="code-block">
                    <div class="code-header">~/.ssh/config</div>
                    <pre><code><span class="cm"># Общие настройки для всех хостов</span>
<span class="kw">Host</span> <span class="st">*</span>
    <span class="kw">ServerAliveInterval</span> <span class="fl">60</span>
    <span class="kw">ServerAliveCountMax</span> <span class="fl">3</span>
    <span class="kw">AddKeysToAgent</span> <span class="st">yes</span>

<span class="cm"># Продакшн-сервер</span>
<span class="kw">Host</span> <span class="st">prod</span>
    <span class="kw">HostName</span> <span class="st">203.0.113.50</span>
    <span class="kw">User</span> <span class="st">deploy</span>
    <span class="kw">Port</span> <span class="fl">2222</span>
    <span class="kw">IdentityFile</span> <span class="st">~/.ssh/prod_key</span>

<span class="cm"># Стейджинг через бастион-хост</span>
<span class="kw">Host</span> <span class="st">staging</span>
    <span class="kw">HostName</span> <span class="st">10.0.1.50</span>
    <span class="kw">User</span> <span class="st">deploy</span>
    <span class="kw">ProxyJump</span> <span class="st">bastion</span>

<span class="cm"># Бастион-хост (jump host)</span>
<span class="kw">Host</span> <span class="st">bastion</span>
    <span class="kw">HostName</span> <span class="st">203.0.113.10</span>
    <span class="kw">User</span> <span class="st">admin</span>
    <span class="kw">IdentityFile</span> <span class="st">~/.ssh/bastion_key</span></code></pre>
                </div>

                <p>После настройки конфигурационного файла подключение упрощается до одной команды: <code>ssh prod</code> вместо <code>ssh -i ~/.ssh/prod_key -p 2222 deploy@203.0.113.50</code>. Это не только удобно, но и снижает вероятность ошибки.</p>

                <h3>Проброс портов и передача файлов</h3>

                <div class="code-block">
                    <div class="code-header">SSH Port Forwarding и файлы</div>
                    <pre><code><span class="cm"># Локальный проброс: доступ к удалённой БД через localhost:5432</span>
<span class="fn">ssh</span> <span class="fl">-L</span> <span class="fl">5432</span>:<span class="st">db-server</span>:<span class="fl">5432</span> <span class="st">bastion</span>

<span class="cm"># Обратный проброс: сделать локальный порт 3000 доступным</span>
<span class="cm"># на удалённом сервере как порт 8080</span>
<span class="fn">ssh</span> <span class="fl">-R</span> <span class="fl">8080</span>:<span class="st">localhost</span>:<span class="fl">3000</span> <span class="st">server</span>

<span class="cm"># SOCKS-прокси на локальном порту 1080</span>
<span class="fn">ssh</span> <span class="fl">-D</span> <span class="fl">1080</span> <span class="st">server</span>

<span class="cm"># Копирование файлов через SCP</span>
<span class="fn">scp</span> <span class="st">file.tar.gz</span> <span class="st">user@server:/tmp/</span>
<span class="fn">scp</span> <span class="fl">-r</span> <span class="st">user@server:/var/log/</span> <span class="st">./logs/</span>

<span class="cm"># SFTP — интерактивная передача файлов</span>
<span class="fn">sftp</span> <span class="st">user@server</span>
<span class="cm"># sftp> put localfile.txt /remote/path/</span>
<span class="cm"># sftp> get /remote/file.txt ./local/</span></code></pre>
                </div>

                <div class="note">
                    <strong>Безопасность SSH:</strong> отключите парольную аутентификацию (<code>PasswordAuthentication no</code> в <code>/etc/ssh/sshd_config</code>), измените стандартный порт, используйте <code>fail2ban</code> для защиты от перебора, ограничьте доступ по IP через файрвол.
                </div>
            </div>

            <!-- ===== ФАЙРВОЛЫ ===== -->
            <div class="section">
                <p class="section-label">Безопасность</p>
                <h2>Файрволы и безопасность сети</h2>

                <p><strong>Файрвол (Firewall)</strong> &mdash; это система, фильтрующая сетевой трафик на основе заданных правил. Файрвол анализирует каждый пакет и принимает решение: пропустить (ACCEPT), отбросить (DROP) или отклонить с уведомлением (REJECT). В Linux основным механизмом фильтрации пакетов является <strong>netfilter</strong>, а для управления его правилами используются утилиты <code>iptables</code> (классический инструмент) и <code>nftables</code> (современная замена). Для начинающих существует упрощённая обёртка <strong>UFW (Uncomplicated Firewall)</strong>.</p>

                <p>В <code>iptables</code> правила организованы в <strong>цепочки (chains)</strong>. Три основных цепочки: <strong>INPUT</strong> &mdash; входящий трафик, предназначенный для самой машины; <strong>OUTPUT</strong> &mdash; исходящий трафик от самой машины; <strong>FORWARD</strong> &mdash; транзитный трафик, проходящий через машину (актуально для маршрутизаторов и Docker). Каждая цепочка имеет политику по умолчанию (обычно ACCEPT или DROP). Правила в цепочке проверяются сверху вниз: первое совпавшее правило определяет судьбу пакета.</p>

                <p>В облачных средах файрволы реализуются через <strong>Security Groups</strong> (AWS, OpenStack) или <strong>Firewall Rules</strong> (GCP). В отличие от iptables, облачные файрволы обычно работают как stateful &mdash; если вы разрешили входящее соединение, обратный трафик автоматически пропускается. Это упрощает настройку: достаточно описать только входящие правила. <strong>NAT (Network Address Translation)</strong> позволяет машинам с частными IP-адресами выходить в интернет через общий публичный адрес. Это основа работы домашних маршрутизаторов и облачных NAT Gateway.</p>

                <h3>iptables: основы</h3>

                <div class="code-block">
                    <div class="code-header">Базовые правила iptables</div>
                    <pre><code><span class="cm"># Показать текущие правила</span>
<span class="fn">sudo</span> <span class="fn">iptables</span> <span class="fl">-L -n -v</span>

<span class="cm"># Установить политику по умолчанию: отбрасывать входящий трафик</span>
<span class="fn">sudo</span> <span class="fn">iptables</span> <span class="fl">-P INPUT DROP</span>

<span class="cm"># Разрешить loopback-интерфейс (localhost)</span>
<span class="fn">sudo</span> <span class="fn">iptables</span> <span class="fl">-A INPUT</span> <span class="fl">-i lo</span> <span class="fl">-j ACCEPT</span>

<span class="cm"># Разрешить уже установленные соединения</span>
<span class="fn">sudo</span> <span class="fn">iptables</span> <span class="fl">-A INPUT</span> <span class="fl">-m conntrack</span> <span class="fl">--ctstate ESTABLISHED,RELATED</span> <span class="fl">-j ACCEPT</span>

<span class="cm"># Разрешить SSH (порт 22)</span>
<span class="fn">sudo</span> <span class="fn">iptables</span> <span class="fl">-A INPUT</span> <span class="fl">-p tcp</span> <span class="fl">--dport 22</span> <span class="fl">-j ACCEPT</span>

<span class="cm"># Разрешить HTTP и HTTPS</span>
<span class="fn">sudo</span> <span class="fn">iptables</span> <span class="fl">-A INPUT</span> <span class="fl">-p tcp</span> <span class="fl">--dport 80</span> <span class="fl">-j ACCEPT</span>
<span class="fn">sudo</span> <span class="fn">iptables</span> <span class="fl">-A INPUT</span> <span class="fl">-p tcp</span> <span class="fl">--dport 443</span> <span class="fl">-j ACCEPT</span>

<span class="cm"># Разрешить SSH только из определённой подсети</span>
<span class="fn">sudo</span> <span class="fn">iptables</span> <span class="fl">-A INPUT</span> <span class="fl">-p tcp</span> <span class="fl">-s 10.0.0.0/8</span> <span class="fl">--dport 22</span> <span class="fl">-j ACCEPT</span>

<span class="cm"># Сохранить правила (Ubuntu/Debian)</span>
<span class="fn">sudo</span> <span class="fn">iptables-save</span> > <span class="st">/etc/iptables/rules.v4</span></code></pre>
                </div>

                <h3>UFW: упрощённый файрвол</h3>

                <div class="code-block">
                    <div class="code-header">Управление UFW</div>
                    <pre><code><span class="cm"># Включить UFW с политикой по умолчанию</span>
<span class="fn">sudo</span> <span class="fn">ufw</span> <span class="st">default deny incoming</span>
<span class="fn">sudo</span> <span class="fn">ufw</span> <span class="st">default allow outgoing</span>

<span class="cm"># Разрешить SSH, HTTP, HTTPS</span>
<span class="fn">sudo</span> <span class="fn">ufw</span> <span class="st">allow 22/tcp</span>
<span class="fn">sudo</span> <span class="fn">ufw</span> <span class="st">allow 80/tcp</span>
<span class="fn">sudo</span> <span class="fn">ufw</span> <span class="st">allow 443/tcp</span>

<span class="cm"># Разрешить SSH только из определённой подсети</span>
<span class="fn">sudo</span> <span class="fn">ufw</span> <span class="st">allow from 10.0.0.0/8 to any port 22</span>

<span class="cm"># Включить файрвол</span>
<span class="fn">sudo</span> <span class="fn">ufw</span> <span class="st">enable</span>

<span class="cm"># Проверить статус и правила</span>
<span class="fn">sudo</span> <span class="fn">ufw</span> <span class="st">status verbose</span>

<span class="cm"># Удалить правило</span>
<span class="fn">sudo</span> <span class="fn">ufw</span> <span class="st">delete allow 80/tcp</span></code></pre>
                </div>

                <h3>NAT и проброс портов</h3>

                <div class="code-block">
                    <div class="code-header">NAT с iptables</div>
                    <pre><code><span class="cm"># Включить маршрутизацию пакетов в ядре</span>
<span class="fn">echo</span> <span class="fl">1</span> > <span class="st">/proc/sys/net/ipv4/ip_forward</span>

<span class="cm"># Или через sysctl (постоянно)</span>
<span class="fn">sudo</span> <span class="fn">sysctl</span> <span class="fl">-w</span> <span class="st">net.ipv4.ip_forward=1</span>

<span class="cm"># SNAT (Source NAT) — для выхода в интернет из приватной сети</span>
<span class="fn">sudo</span> <span class="fn">iptables</span> <span class="fl">-t nat</span> <span class="fl">-A POSTROUTING</span> <span class="fl">-s 10.0.0.0/8</span> <span class="fl">-o eth0</span> <span class="fl">-j MASQUERADE</span>

<span class="cm"># DNAT (Destination NAT) — проброс порта 8080 на внутренний сервер</span>
<span class="fn">sudo</span> <span class="fn">iptables</span> <span class="fl">-t nat</span> <span class="fl">-A PREROUTING</span> <span class="fl">-p tcp</span> <span class="fl">--dport 8080</span> \
     <span class="fl">-j DNAT</span> <span class="fl">--to-destination</span> <span class="st">10.0.1.50:80</span></code></pre>
                </div>

                <div class="note">
                    <strong>Важно:</strong> при настройке файрвола всегда сначала добавляйте правило для SSH, а потом устанавливайте политику DROP. Иначе вы потеряете доступ к серверу. Проверяйте правила командой <code>iptables -L -n</code> перед применением.
                </div>
            </div>

            <!-- ===== ПОШАГОВЫЙ ТУТОРИАЛ ===== -->
            <div class="section">
                <p class="section-label">Практика</p>
                <h2>Пошаговый туториал</h2>
                <p>Настроим Nginx как обратный прокси-сервер (reverse proxy) для веб-приложения с SSL-сертификатом от Let's Encrypt. Это одна из самых типичных задач DevOps-инженера. Предполагается, что у вас есть сервер с Ubuntu и доменное имя, указывающее на его IP-адрес.</p>

                <div class="step">
                    <div class="step-num">Шаг 1 — Обновление системы и установка Nginx</div>
                    <p>Начнём с обновления списка пакетов и установки Nginx. Nginx &mdash; высокопроизводительный веб-сервер и обратный прокси, который де-факто стал стандартом для обслуживания веб-приложений в DevOps.</p>
                    <div class="code-block">
                        <div class="code-header">bash</div>
                        <pre><code><span class="cm"># Обновляем список пакетов</span>
<span class="fn">sudo</span> <span class="fn">apt</span> <span class="st">update</span> && <span class="fn">sudo</span> <span class="fn">apt</span> <span class="st">upgrade</span> <span class="fl">-y</span>

<span class="cm"># Устанавливаем Nginx</span>
<span class="fn">sudo</span> <span class="fn">apt</span> <span class="st">install</span> <span class="st">nginx</span> <span class="fl">-y</span>

<span class="cm"># Проверяем, что Nginx запущен</span>
<span class="fn">sudo</span> <span class="fn">systemctl</span> <span class="st">status</span> <span class="st">nginx</span>

<span class="cm"># Открываем порты в файрволе</span>
<span class="fn">sudo</span> <span class="fn">ufw</span> <span class="st">allow</span> <span class="st">'Nginx Full'</span>
<span class="fn">sudo</span> <span class="fn">ufw</span> <span class="st">allow</span> <span class="st">OpenSSH</span>
<span class="fn">sudo</span> <span class="fn">ufw</span> <span class="st">enable</span></code></pre>
                    </div>
                </div>

                <div class="step">
                    <div class="step-num">Шаг 2 — Настройка конфигурации Nginx как обратного прокси</div>
                    <p>Создадим конфигурационный файл для нашего домена. Предположим, что веб-приложение запущено локально на порту 3000 (например, Node.js или Python). Nginx будет принимать HTTP-запросы на порту 80 и проксировать их к приложению.</p>
                    <div class="code-block">
                        <div class="code-header">/etc/nginx/sites-available/myapp.conf</div>
                        <pre><code><span class="kw">server</span> {
    <span class="kw">listen</span> <span class="fl">80</span>;
    <span class="kw">server_name</span> <span class="st">myapp.example.com</span>;

    <span class="cm"># Логи</span>
    <span class="kw">access_log</span> <span class="st">/var/log/nginx/myapp_access.log</span>;
    <span class="kw">error_log</span>  <span class="st">/var/log/nginx/myapp_error.log</span>;

    <span class="kw">location</span> / {
        <span class="cm"># Проксирование на приложение</span>
        <span class="kw">proxy_pass</span> <span class="st">http://127.0.0.1:3000</span>;

        <span class="cm"># Передаём оригинальные заголовки</span>
        <span class="kw">proxy_set_header</span> Host <span class="st">$host</span>;
        <span class="kw">proxy_set_header</span> X-Real-IP <span class="st">$remote_addr</span>;
        <span class="kw">proxy_set_header</span> X-Forwarded-For <span class="st">$proxy_add_x_forwarded_for</span>;
        <span class="kw">proxy_set_header</span> X-Forwarded-Proto <span class="st">$scheme</span>;

        <span class="cm"># Настройки для WebSocket (если нужно)</span>
        <span class="kw">proxy_http_version</span> <span class="fl">1.1</span>;
        <span class="kw">proxy_set_header</span> Upgrade <span class="st">$http_upgrade</span>;
        <span class="kw">proxy_set_header</span> Connection <span class="st">"upgrade"</span>;
    }
}</code></pre>
                    </div>
                    <div class="code-block">
                        <div class="code-header">Активация конфигурации</div>
                        <pre><code><span class="cm"># Создаём символическую ссылку для активации</span>
<span class="fn">sudo</span> <span class="fn">ln</span> <span class="fl">-s</span> <span class="st">/etc/nginx/sites-available/myapp.conf</span> \
    <span class="st">/etc/nginx/sites-enabled/</span>

<span class="cm"># Проверяем синтаксис конфигурации</span>
<span class="fn">sudo</span> <span class="fn">nginx</span> <span class="fl">-t</span>

<span class="cm"># Перезагружаем Nginx</span>
<span class="fn">sudo</span> <span class="fn">systemctl</span> <span class="st">reload</span> <span class="st">nginx</span></code></pre>
                    </div>
                </div>

                <div class="step">
                    <div class="step-num">Шаг 3 — Установка Certbot и получение SSL-сертификата</div>
                    <p>Установим Certbot &mdash; официальный клиент Let's Encrypt &mdash; и получим бесплатный SSL-сертификат для нашего домена. Certbot автоматически модифицирует конфигурацию Nginx для работы с HTTPS.</p>
                    <div class="code-block">
                        <div class="code-header">bash</div>
                        <pre><code><span class="cm"># Устанавливаем Certbot и плагин для Nginx</span>
<span class="fn">sudo</span> <span class="fn">apt</span> <span class="st">install</span> <span class="st">certbot</span> <span class="st">python3-certbot-nginx</span> <span class="fl">-y</span>

<span class="cm"># Получаем сертификат и автоматически настраиваем Nginx</span>
<span class="fn">sudo</span> <span class="fn">certbot</span> <span class="fl">--nginx</span> <span class="fl">-d</span> <span class="st">myapp.example.com</span>

<span class="cm"># Certbot спросит email для уведомлений</span>
<span class="cm"># и предложит перенаправлять HTTP → HTTPS (выберите 2)</span>

<span class="cm"># Проверяем автоматическое продление</span>
<span class="fn">sudo</span> <span class="fn">certbot</span> <span class="st">renew</span> <span class="fl">--dry-run</span></code></pre>
                    </div>
                </div>

                <div class="step">
                    <div class="step-num">Шаг 4 — Проверка итоговой конфигурации</div>
                    <p>После работы Certbot конфигурация Nginx будет автоматически дополнена секциями для HTTPS. Давайте посмотрим, как выглядит итоговый файл, и убедимся, что всё работает корректно.</p>
                    <div class="code-block">
                        <div class="code-header">/etc/nginx/sites-available/myapp.conf (после Certbot)</div>
                        <pre><code><span class="kw">server</span> {
    <span class="kw">listen</span> <span class="fl">80</span>;
    <span class="kw">server_name</span> <span class="st">myapp.example.com</span>;

    <span class="cm"># Certbot добавит редирект на HTTPS</span>
    <span class="kw">return</span> <span class="fl">301</span> https://<span class="st">$host$request_uri</span>;
}

<span class="kw">server</span> {
    <span class="kw">listen</span> <span class="fl">443</span> <span class="st">ssl</span>;
    <span class="kw">server_name</span> <span class="st">myapp.example.com</span>;

    <span class="cm"># SSL-сертификаты от Let's Encrypt</span>
    <span class="kw">ssl_certificate</span>     <span class="st">/etc/letsencrypt/live/myapp.example.com/fullchain.pem</span>;
    <span class="kw">ssl_certificate_key</span> <span class="st">/etc/letsencrypt/live/myapp.example.com/privkey.pem</span>;
    <span class="kw">include</span>             <span class="st">/etc/letsencrypt/options-ssl-nginx.conf</span>;
    <span class="kw">ssl_dhparam</span>         <span class="st">/etc/letsencrypt/ssl-dhparams.pem</span>;

    <span class="kw">access_log</span> <span class="st">/var/log/nginx/myapp_access.log</span>;
    <span class="kw">error_log</span>  <span class="st">/var/log/nginx/myapp_error.log</span>;

    <span class="kw">location</span> / {
        <span class="kw">proxy_pass</span> <span class="st">http://127.0.0.1:3000</span>;
        <span class="kw">proxy_set_header</span> Host <span class="st">$host</span>;
        <span class="kw">proxy_set_header</span> X-Real-IP <span class="st">$remote_addr</span>;
        <span class="kw">proxy_set_header</span> X-Forwarded-For <span class="st">$proxy_add_x_forwarded_for</span>;
        <span class="kw">proxy_set_header</span> X-Forwarded-Proto <span class="st">$scheme</span>;
        <span class="kw">proxy_http_version</span> <span class="fl">1.1</span>;
        <span class="kw">proxy_set_header</span> Upgrade <span class="st">$http_upgrade</span>;
        <span class="kw">proxy_set_header</span> Connection <span class="st">"upgrade"</span>;
    }
}</code></pre>
                    </div>
                </div>

                <div class="step">
                    <div class="step-num">Шаг 5 — Тестирование и мониторинг</div>
                    <p>Убедимся, что всё работает: сертификат валиден, редирект с HTTP на HTTPS функционирует, а приложение отвечает корректно через обратный прокси.</p>
                    <div class="code-block">
                        <div class="code-header">bash</div>
                        <pre><code><span class="cm"># Проверяем синтаксис конфигурации</span>
<span class="fn">sudo</span> <span class="fn">nginx</span> <span class="fl">-t</span>

<span class="cm"># Перезагружаем Nginx</span>
<span class="fn">sudo</span> <span class="fn">systemctl</span> <span class="st">reload</span> <span class="st">nginx</span>

<span class="cm"># Проверяем редирект с HTTP на HTTPS</span>
<span class="fn">curl</span> <span class="fl">-I</span> <span class="st">http://myapp.example.com</span>
<span class="cm"># Должен вернуть: 301 Moved Permanently</span>
<span class="cm"># Location: https://myapp.example.com/</span>

<span class="cm"># Проверяем HTTPS</span>
<span class="fn">curl</span> <span class="fl">-I</span> <span class="st">https://myapp.example.com</span>
<span class="cm"># Должен вернуть: 200 OK</span>

<span class="cm"># Проверяем SSL-сертификат</span>
<span class="fn">echo</span> | <span class="fn">openssl</span> <span class="st">s_client</span> <span class="fl">-connect</span> <span class="st">myapp.example.com:443</span> <span class="fl">2>/dev/null</span> | \
    <span class="fn">openssl</span> <span class="st">x509</span> <span class="fl">-noout</span> <span class="fl">-dates</span>

<span class="cm"># Мониторим логи в реальном времени</span>
<span class="fn">sudo</span> <span class="fn">tail</span> <span class="fl">-f</span> <span class="st">/var/log/nginx/myapp_access.log</span></code></pre>
                    </div>
                </div>

                <div class="note">
                    <strong>Автопродление:</strong> Certbot автоматически создаёт systemd timer или cron-задание для продления сертификатов. Проверьте: <code>systemctl list-timers | grep certbot</code>. Сертификаты Let's Encrypt действительны 90 дней, продление запускается при оставшемся сроке менее 30 дней.
                </div>
            </div>

            <!-- ===== ПРАКТИКА ===== -->
            <div class="practice">
                <h3>Практические задания</h3>
                <ol>
                    <li><strong>Рассчитайте подсеть:</strong> для сети <code>172.16.50.0/22</code> определите диапазон адресов, количество доступных хостов, адрес сети и широковещательный адрес. Проверьте свои расчёты с помощью утилиты <code>ipcalc</code>.</li>
                    <li><strong>Исследуйте DNS:</strong> с помощью <code>dig +trace</code> проследите полный путь разрешения DNS для домена <code>google.com</code>. Запишите все промежуточные серверы. Затем с помощью <code>dig</code> получите записи A, MX, NS и TXT для любого популярного домена.</li>
                    <li><strong>Настройте SSH-конфигурацию:</strong> создайте файл <code>~/.ssh/config</code> с тремя хостами (dev, staging, prod). Сгенерируйте отдельные SSH-ключи для каждого. Настройте ProxyJump для доступа к staging через bastion-хост.</li>
                    <li><strong>Настройте файрвол:</strong> на тестовой виртуальной машине настройте UFW: закройте всё по умолчанию, откройте порты 22, 80 и 443, разрешите SSH только из вашей подсети. Проверьте правила командой <code>ufw status verbose</code> и протестируйте с помощью <code>nc -zv</code>.</li>
                    <li><strong>Разверните Nginx с SSL:</strong> на VPS или в виртуальной машине установите Nginx, настройте его как обратный прокси для простого приложения (или статической страницы), получите SSL-сертификат через Certbot и убедитесь, что редирект с HTTP на HTTPS работает.</li>
                </ol>
            </div>

            <!-- ===== РЕСУРСЫ ===== -->
            <div class="resources">
                <h3>Полезные ресурсы</h3>
                <ul>
                    <li>
                        <a href="https://www.cloudflare.com/learning/" target="_blank">Cloudflare Learning Center</a>
                        <div class="res-desc">Отличные наглядные объяснения DNS, HTTP, SSL/TLS, DDoS и других сетевых тем</div>
                    </li>
                    <li>
                        <a href="https://www.youtube.com/playlist?list=PLowKtXNTBypH19whXTVoG3oKSuOcw_XeW" target="_blank">Ben Eater &mdash; Networking Tutorial</a>
                        <div class="res-desc">Серия видео о сетях на низком уровне: Ethernet, ARP, IP, TCP, HTTP</div>
                    </li>
                    <li>
                        <a href="https://jvns.ca/networking-zine.pdf" target="_blank">Julia Evans &mdash; Networking Zine</a>
                        <div class="res-desc">Визуальное пособие по сетям с понятными иллюстрациями</div>
                    </li>
                    <li>
                        <a href="https://nginx.org/en/docs/" target="_blank">Nginx Documentation</a>
                        <div class="res-desc">Официальная документация Nginx: конфигурация, модули, reverse proxy</div>
                    </li>
                    <li>
                        <a href="https://www.digitalocean.com/community/tutorial-series/networking-for-cloud" target="_blank">DigitalOcean &mdash; Networking for Cloud</a>
                        <div class="res-desc">Практические руководства по сетям в облачных окружениях</div>
                    </li>
                    <li>
                        <a href="https://letsencrypt.org/docs/" target="_blank">Let's Encrypt Documentation</a>
                        <div class="res-desc">Документация Let's Encrypt: получение сертификатов, автопродление, ACME-протокол</div>
                    </li>
                </ul>
            </div>

            <!-- ===== ОТМЕТКА ===== -->
            <label class="mark-complete">
                <input type="checkbox" id="topicCheckbox" data-topic="network">
                <span>Отметить тему как изученную</span>
            </label>

            <!-- ===== НАВИГАЦИЯ ===== -->
            <div class="bottom-nav">
                <div class="prev">
                    <div class="nav-label">Назад</div>
                    <a href="linux.html" class="nav-title">&larr; Linux</a>
                </div>
                <div class="next">
                    <div class="nav-label">Далее</div>
                    <a href="git.html" class="nav-title">Git &rarr;</a>
                </div>
            </div>

        </div>
    </main>
    <script src="../app.js"></script>
</body>
</html>
